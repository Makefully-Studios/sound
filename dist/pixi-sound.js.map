{"version":3,"file":"pixi-sound.js","sources":["../src/instance.ts","../src/filters/Filter.ts","../src/filters/DistortionFilter.ts","../src/webaudio/WebAudioUtils.ts","../src/filters/EqualizerFilter.ts","../src/filters/MonoFilter.ts","../src/filters/ReverbFilter.ts","../src/filters/StereoFilter.ts","../src/filters/StreamFilter.ts","../src/filters/TelephoneFilter.ts","../src/htmlaudio/HTMLAudioContext.ts","../src/htmlaudio/HTMLAudioInstance.ts","../src/htmlaudio/HTMLAudioMedia.ts","../src/SoundSprite.ts","../src/utils/supported.ts","../src/webaudio/WebAudioInstance.ts","../src/Filterable.ts","../src/webaudio/WebAudioNodes.ts","../src/webaudio/WebAudioMedia.ts","../src/Sound.ts","../src/webaudio/WebAudioContext.ts","../src/SoundLibrary.ts","../src/utils/playOnce.ts","../src/utils/render.ts","../src/utils/sineTone.ts","../src/soundAsset.ts","../src/index.ts","../src/browser.ts"],"sourcesContent":["import { SoundLibrary } from './SoundLibrary';\r\n\r\n/**\r\n * Singleton instance of the SoundLibrary\r\n */\r\nlet instance: SoundLibrary;\r\n\r\n/**\r\n * Internal set function for the singleton instance.\r\n * @ignore\r\n * @param sound - - Sound library instance\r\n */\r\nfunction setInstance(sound: SoundLibrary): SoundLibrary\r\n{\r\n    instance = sound;\r\n\r\n    return sound;\r\n}\r\n\r\n/**\r\n * Internal get function for the singleton instance.\r\n * @ignore\r\n */\r\nfunction getInstance(): SoundLibrary\r\n{\r\n    return instance;\r\n}\r\n\r\nexport { getInstance, instance, setInstance };\r\n","/**\r\n * Represents a single sound element. Can be used to play, pause, etc. sound instances.\r\n *\r\n * @memberof filters\r\n */\r\nclass Filter\r\n{\r\n    /** The node to connect for the filter to the previous filter. */\r\n    public destination: AudioNode;\r\n\r\n    /** The node to connect for the filter to the previous filter. */\r\n    public source: AudioNode;\r\n\r\n    /**\r\n     * @param {AudioNode} destination - The audio node to use as the destination for the input AudioNode\r\n     * @param {AudioNode} [source] - Optional output node, defaults to destination node. This is useful\r\n     *        when creating filters which contains multiple AudioNode elements chained together.\r\n     */\r\n    constructor(destination: AudioNode, source?: AudioNode)\r\n    {\r\n        this.init(destination, source);\r\n    }\r\n\r\n    /** Reinitialize */\r\n    protected init(destination: AudioNode, source?: AudioNode): void\r\n    {\r\n        this.destination = destination;\r\n        this.source = source || destination;\r\n    }\r\n\r\n    /**\r\n     * Connect to the destination.\r\n     * @param {AudioNode} destination - The destination node to connect the output to\r\n     */\r\n    public connect(destination: AudioNode): void\r\n    {\r\n        this.source?.connect(destination);\r\n    }\r\n\r\n    /** Completely disconnect filter from destination and source nodes. */\r\n    public disconnect(): void\r\n    {\r\n        this.source?.disconnect();\r\n    }\r\n\r\n    /** Destroy the filter and don't use after this. */\r\n    public destroy(): void\r\n    {\r\n        this.disconnect();\r\n        this.destination = null;\r\n        this.source = null;\r\n    }\r\n}\r\n\r\nexport { Filter };\r\n","import { getInstance } from '../instance';\r\nimport { Filter } from './Filter';\r\n\r\n/**\r\n * Filter for adding adding delaynode.\r\n *\r\n * @memberof filters\r\n */\r\nclass DistortionFilter extends Filter\r\n{\r\n    /** The Wave shape node use to distort */\r\n    private _distortion: WaveShaperNode;\r\n\r\n    /** The amount of distoration */\r\n    private _amount: number;\r\n\r\n    /** @param amount - The amount of distoration from 0 to 1. */\r\n    constructor(amount = 0)\r\n    {\r\n        let distortion: WaveShaperNode;\r\n\r\n        if (!getInstance().useLegacy)\r\n        {\r\n            const { audioContext } = getInstance().context;\r\n\r\n            distortion = audioContext.createWaveShaper();\r\n        }\r\n\r\n        super(distortion);\r\n\r\n        this._distortion = distortion;\r\n\r\n        this.amount = amount;\r\n    }\r\n\r\n    /** The amount of distortion to set. */\r\n    set amount(value: number)\r\n    {\r\n        this._amount = value;\r\n        if (getInstance().useLegacy)\r\n        {\r\n            return;\r\n        }\r\n        const scaledValue = value * 1000;\r\n        const samples = 44100;\r\n        const curve: Float32Array = new Float32Array(samples);\r\n        const deg: number = Math.PI / 180;\r\n\r\n        let i = 0;\r\n        let x: number;\r\n\r\n        for (; i < samples; ++i)\r\n        {\r\n            x = (i * 2 / samples) - 1;\r\n            curve[i] = (3 + scaledValue) * x * 20 * deg / (Math.PI + (scaledValue * Math.abs(x)));\r\n        }\r\n        this._distortion.curve = curve;\r\n        this._distortion.oversample = '4x';\r\n    }\r\n    get amount(): number\r\n    {\r\n        return this._amount;\r\n    }\r\n\r\n    public destroy(): void\r\n    {\r\n        this._distortion = null;\r\n        super.destroy();\r\n    }\r\n}\r\n\r\nexport { DistortionFilter };\r\n","import { getInstance } from '../instance';\r\nimport { WebAudioContext } from './WebAudioContext';\r\n\r\n/**\r\n * Internal class for Web Audio abstractions and convenience methods.\r\n * @memberof webaudio\r\n */\r\nclass WebAudioUtils\r\n{\r\n    /**\r\n     * Dezippering is removed in the future Web Audio API, instead\r\n     * we use the `setValueAtTime` method, however, this is not available\r\n     * in all environments (e.g., Android webview), so we fallback to the `value` setter.\r\n     * @param param - AudioNode parameter object\r\n     * @param value - Value to set\r\n     * @return The value set\r\n     */\r\n    public static setParamValue(param: AudioParam, value: number): number\r\n    {\r\n        if (param.setValueAtTime)\r\n        {\r\n            const context = getInstance().context as WebAudioContext;\r\n\r\n            param.setValueAtTime(value, context.audioContext.currentTime);\r\n        }\r\n        else\r\n        {\r\n            param.value = value;\r\n        }\r\n\r\n        return value;\r\n    }\r\n}\r\n\r\nexport { WebAudioUtils };\r\n","import { getInstance } from '../instance';\r\nimport { WebAudioUtils } from '../webaudio/WebAudioUtils';\r\nimport { Filter } from './Filter';\r\n\r\ninterface Band\r\n{\r\n    f: number;\r\n    type: string;\r\n    gain: number;\r\n}\r\n\r\n/**\r\n * Filter for adding equalizer bands.\r\n *\r\n * @memberof filters\r\n */\r\nclass EqualizerFilter extends Filter\r\n{\r\n    /**\r\n     * Band at 32 Hz\r\n     * @readonly\r\n     */\r\n    public static readonly F32: number = 32;\r\n\r\n    /**\r\n     * Band at 64 Hz\r\n     * @readonly\r\n     */\r\n    public static readonly F64: number = 64;\r\n\r\n    /**\r\n     * Band at 125 Hz\r\n     * @readonly\r\n     */\r\n    public static readonly F125: number = 125;\r\n\r\n    /**\r\n     * Band at 250 Hz\r\n     * @readonly\r\n     */\r\n    public static readonly F250: number = 250;\r\n\r\n    /**\r\n     * Band at 500 Hz\r\n     * @readonly\r\n     */\r\n    public static readonly F500: number = 500;\r\n\r\n    /**\r\n     * Band at 1000 Hz\r\n     * @readonly\r\n     */\r\n    public static readonly F1K: number = 1000;\r\n\r\n    /**\r\n     * Band at 2000 Hz\r\n     * @readonly\r\n     */\r\n    public static readonly F2K: number = 2000;\r\n\r\n    /**\r\n     * Band at 4000 Hz\r\n     * @readonly\r\n     */\r\n    public static readonly F4K: number = 4000;\r\n\r\n    /**\r\n     * Band at 8000 Hz\r\n     * @readonly\r\n     */\r\n    public static readonly F8K: number = 8000;\r\n\r\n    /**\r\n     * Band at 16000 Hz\r\n     * @readonly\r\n     */\r\n    public static readonly F16K: number = 16000;\r\n\r\n    /**\r\n     * The list of bands\r\n     * @readonly\r\n     */\r\n    public readonly bands: BiquadFilterNode[];\r\n\r\n    /**\r\n     * The map of bands to frequency\r\n     * @readonly\r\n     */\r\n    public readonly bandsMap: Record<number, BiquadFilterNode>;\r\n\r\n    /**\r\n     * @param f32 - Default gain for 32 Hz\r\n     * @param f64 - Default gain for 64 Hz\r\n     * @param f125 - Default gain for 125 Hz\r\n     * @param f250 - Default gain for 250 Hz\r\n     * @param f500 - Default gain for 500 Hz\r\n     * @param f1k - Default gain for 1000 Hz\r\n     * @param f2k - Default gain for 2000 Hz\r\n     * @param f4k - Default gain for 4000 Hz\r\n     * @param f8k - Default gain for 8000 Hz\r\n     * @param f16k - Default gain for 16000 Hz\r\n     */\r\n    constructor(f32 = 0, f64 = 0, f125 = 0, f250 = 0, f500 = 0,\r\n        f1k = 0, f2k = 0, f4k = 0, f8k = 0, f16k = 0)\r\n    {\r\n        let bands: BiquadFilterNode[] = [];\r\n\r\n        const equalizerBands: Band[] = [\r\n            {\r\n                f: EqualizerFilter.F32,\r\n                type: 'lowshelf',\r\n                gain: f32,\r\n            },\r\n            {\r\n                f: EqualizerFilter.F64,\r\n                type: 'peaking',\r\n                gain: f64,\r\n            },\r\n            {\r\n                f: EqualizerFilter.F125,\r\n                type: 'peaking',\r\n                gain: f125,\r\n            },\r\n            {\r\n                f: EqualizerFilter.F250,\r\n                type: 'peaking',\r\n                gain: f250,\r\n            },\r\n            {\r\n                f: EqualizerFilter.F500,\r\n                type: 'peaking',\r\n                gain: f500,\r\n            },\r\n            {\r\n                f: EqualizerFilter.F1K,\r\n                type: 'peaking',\r\n                gain: f1k,\r\n            },\r\n            {\r\n                f: EqualizerFilter.F2K,\r\n                type: 'peaking',\r\n                gain: f2k,\r\n            },\r\n            {\r\n                f: EqualizerFilter.F4K,\r\n                type: 'peaking',\r\n                gain: f4k,\r\n            },\r\n            {\r\n                f: EqualizerFilter.F8K,\r\n                type: 'peaking',\r\n                gain: f8k,\r\n            },\r\n            {\r\n                f: EqualizerFilter.F16K,\r\n                type: 'highshelf',\r\n                gain: f16k,\r\n            },\r\n        ];\r\n\r\n        if (!getInstance().useLegacy)\r\n        {\r\n            bands = equalizerBands.map((band: Band) =>\r\n            {\r\n                const node: BiquadFilterNode = getInstance().context.audioContext.createBiquadFilter();\r\n\r\n                node.type = band.type as BiquadFilterType;\r\n                WebAudioUtils.setParamValue(node.Q, 1);\r\n                node.frequency.value = band.f; // WebAudioUtils.setParamValue(filter.frequency, band.f);\r\n                WebAudioUtils.setParamValue(node.gain, band.gain);\r\n\r\n                return node;\r\n            });\r\n        }\r\n\r\n        // Setup the constructor AudioNode, where first is the input, and last is the output\r\n        super(bands[0], bands[bands.length - 1]);\r\n\r\n        // Manipulate the bands\r\n        this.bands = bands;\r\n\r\n        // Create a map\r\n        this.bandsMap = {};\r\n\r\n        for (let i = 0; i < this.bands.length; i++)\r\n        {\r\n            const node: BiquadFilterNode = this.bands[i];\r\n\r\n            // Connect the previous band to the current one\r\n            if (i > 0)\r\n            {\r\n                this.bands[i - 1].connect(node);\r\n            }\r\n            this.bandsMap[node.frequency.value] = node;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set gain on a specific frequency.\r\n     * @param frequency - The frequency, see EqualizerFilter.F* for bands\r\n     * @param gain - Recommended -40 to 40.\r\n     */\r\n    public setGain(frequency: number, gain = 0): void\r\n    {\r\n        if (!this.bandsMap[frequency])\r\n        {\r\n            throw new Error(`No band found for frequency ${frequency}`);\r\n        }\r\n        WebAudioUtils.setParamValue(this.bandsMap[frequency].gain, gain);\r\n    }\r\n\r\n    /**\r\n     * Get gain amount on a specific frequency.\r\n     * @return The amount of gain set.\r\n     */\r\n    public getGain(frequency: number): number\r\n    {\r\n        if (!this.bandsMap[frequency])\r\n        {\r\n            throw new Error(`No band found for frequency ${frequency}`);\r\n        }\r\n\r\n        return this.bandsMap[frequency].gain.value;\r\n    }\r\n\r\n    /**\r\n     * Gain at 32 Hz frequencey.\r\n     * @default 0\r\n     */\r\n    public set f32(value: number)\r\n    {\r\n        this.setGain(EqualizerFilter.F32, value);\r\n    }\r\n    public get f32(): number\r\n    {\r\n        return this.getGain(EqualizerFilter.F32);\r\n    }\r\n\r\n    /**\r\n     * Gain at 64 Hz frequencey.\r\n     * @default 0\r\n     */\r\n    public set f64(value: number)\r\n    {\r\n        this.setGain(EqualizerFilter.F64, value);\r\n    }\r\n    public get f64(): number\r\n    {\r\n        return this.getGain(EqualizerFilter.F64);\r\n    }\r\n\r\n    /**\r\n     * Gain at 125 Hz frequencey.\r\n     * @default 0\r\n     */\r\n    public set f125(value: number)\r\n    {\r\n        this.setGain(EqualizerFilter.F125, value);\r\n    }\r\n    public get f125(): number\r\n    {\r\n        return this.getGain(EqualizerFilter.F125);\r\n    }\r\n\r\n    /**\r\n     * Gain at 250 Hz frequencey.\r\n     * @default 0\r\n     */\r\n    public set f250(value: number)\r\n    {\r\n        this.setGain(EqualizerFilter.F250, value);\r\n    }\r\n    public get f250(): number\r\n    {\r\n        return this.getGain(EqualizerFilter.F250);\r\n    }\r\n\r\n    /**\r\n     * Gain at 500 Hz frequencey.\r\n     * @default 0\r\n     */\r\n    public set f500(value: number)\r\n    {\r\n        this.setGain(EqualizerFilter.F500, value);\r\n    }\r\n    public get f500(): number\r\n    {\r\n        return this.getGain(EqualizerFilter.F500);\r\n    }\r\n\r\n    /**\r\n     * Gain at 1 KHz frequencey.\r\n     * @default 0\r\n     */\r\n    public set f1k(value: number)\r\n    {\r\n        this.setGain(EqualizerFilter.F1K, value);\r\n    }\r\n    public get f1k(): number\r\n    {\r\n        return this.getGain(EqualizerFilter.F1K);\r\n    }\r\n\r\n    /**\r\n     * Gain at 2 KHz frequencey.\r\n     * @default 0\r\n     */\r\n    public set f2k(value: number)\r\n    {\r\n        this.setGain(EqualizerFilter.F2K, value);\r\n    }\r\n    public get f2k(): number\r\n    {\r\n        return this.getGain(EqualizerFilter.F2K);\r\n    }\r\n\r\n    /**\r\n     * Gain at 4 KHz frequencey.\r\n     * @default 0\r\n     */\r\n    public set f4k(value: number)\r\n    {\r\n        this.setGain(EqualizerFilter.F4K, value);\r\n    }\r\n    public get f4k(): number\r\n    {\r\n        return this.getGain(EqualizerFilter.F4K);\r\n    }\r\n\r\n    /**\r\n     * Gain at 8 KHz frequencey.\r\n     * @default 0\r\n     */\r\n    public set f8k(value: number)\r\n    {\r\n        this.setGain(EqualizerFilter.F8K, value);\r\n    }\r\n    public get f8k(): number\r\n    {\r\n        return this.getGain(EqualizerFilter.F8K);\r\n    }\r\n\r\n    /**\r\n     * Gain at 16 KHz frequencey.\r\n     * @default 0\r\n     */\r\n    public set f16k(value: number)\r\n    {\r\n        this.setGain(EqualizerFilter.F16K, value);\r\n    }\r\n    public get f16k(): number\r\n    {\r\n        return this.getGain(EqualizerFilter.F16K);\r\n    }\r\n\r\n    /** Reset all frequency bands to have gain of 0 */\r\n    public reset(): void\r\n    {\r\n        this.bands.forEach((band: BiquadFilterNode) =>\r\n        {\r\n            WebAudioUtils.setParamValue(band.gain, 0);\r\n        });\r\n    }\r\n\r\n    public destroy(): void\r\n    {\r\n        this.bands.forEach((band: BiquadFilterNode) =>\r\n        {\r\n            band.disconnect();\r\n        });\r\n        (this as any).bands = null;\r\n        (this as any).bandsMap = null;\r\n    }\r\n}\r\n\r\nexport { EqualizerFilter };\r\n","import { getInstance } from '../instance';\r\nimport { Filter } from './Filter';\r\n\r\n/**\r\n * Combine all channels into mono channel.\r\n *\r\n * @memberof filters\r\n */\r\nclass MonoFilter extends Filter\r\n{\r\n    /** Merger node */\r\n    private _merger: ChannelMergerNode;\r\n\r\n    constructor()\r\n    {\r\n        let merger: ChannelMergerNode;\r\n        let splitter: ChannelSplitterNode;\r\n\r\n        if (!getInstance().useLegacy)\r\n        {\r\n            const { audioContext } = getInstance().context;\r\n\r\n            splitter = audioContext.createChannelSplitter();\r\n            merger = audioContext.createChannelMerger();\r\n            merger.connect(splitter);\r\n        }\r\n        super(merger, splitter);\r\n        this._merger = merger;\r\n    }\r\n\r\n    public destroy(): void\r\n    {\r\n        this._merger?.disconnect();\r\n        this._merger = null;\r\n        super.destroy();\r\n    }\r\n}\r\n\r\nexport { MonoFilter };\r\n","import { getInstance } from '../instance';\r\nimport { Filter } from './Filter';\r\n\r\n/**\r\n * Filter for adding reverb. Refactored from\r\n * https://github.com/web-audio-components/simple-reverb/\r\n *\r\n * @memberof filters\r\n */\r\nclass ReverbFilter extends Filter\r\n{\r\n    private _seconds: number;\r\n    private _decay: number;\r\n    private _reverse: boolean;\r\n\r\n    /**\r\n     * @param seconds - Seconds for reverb\r\n     * @param decay - The decay length\r\n     * @param reverse - Reverse reverb\r\n     */\r\n    constructor(seconds = 3, decay = 2, reverse = false)\r\n    {\r\n        super(null);\r\n        this._seconds = this._clamp(seconds, 1, 50);\r\n        this._decay = this._clamp(decay, 0, 100);\r\n        this._reverse = reverse;\r\n        this._rebuild();\r\n    }\r\n\r\n    /**\r\n     * Clamp a value\r\n     * @param value\r\n     * @param min - Minimum value\r\n     * @param max - Maximum value\r\n     * @return Clamped number\r\n     */\r\n    private _clamp(value: number, min: number, max: number): number\r\n    {\r\n        return Math.min(max, Math.max(min, value));\r\n    }\r\n\r\n    /**\r\n     * Length of reverb in seconds from 1 to 50\r\n     * @default 3\r\n     */\r\n    get seconds(): number\r\n    {\r\n        return this._seconds;\r\n    }\r\n    set seconds(seconds: number)\r\n    {\r\n        this._seconds = this._clamp(seconds, 1, 50);\r\n        this._rebuild();\r\n    }\r\n\r\n    /**\r\n     * Decay value from 0 to 100\r\n     * @default 2\r\n     */\r\n    get decay(): number\r\n    {\r\n        return this._decay;\r\n    }\r\n    set decay(decay: number)\r\n    {\r\n        this._decay = this._clamp(decay, 0, 100);\r\n        this._rebuild();\r\n    }\r\n\r\n    /**\r\n     * Reverse value from 0 to 1\r\n     * @default false\r\n     */\r\n    get reverse(): boolean\r\n    {\r\n        return this._reverse;\r\n    }\r\n    set reverse(reverse: boolean)\r\n    {\r\n        this._reverse = reverse;\r\n        this._rebuild();\r\n    }\r\n\r\n    /**\r\n     * Utility function for building an impulse response\r\n     * from the module parameters.\r\n     */\r\n    private _rebuild(): void\r\n    {\r\n        if (getInstance().useLegacy)\r\n        {\r\n            return;\r\n        }\r\n        const { audioContext } = getInstance().context;\r\n        const rate: number = audioContext.sampleRate;\r\n        const length: number = rate * this._seconds;\r\n        const impulse: AudioBuffer = audioContext.createBuffer(2, length, rate);\r\n        const impulseL: Float32Array = impulse.getChannelData(0);\r\n        const impulseR: Float32Array = impulse.getChannelData(1);\r\n        let n: number;\r\n\r\n        for (let i = 0; i < length; i++)\r\n        {\r\n            n = this._reverse ? length - i : i;\r\n            impulseL[i] = ((Math.random() * 2) - 1) * Math.pow(1 - (n / length), this._decay);\r\n            impulseR[i] = ((Math.random() * 2) - 1) * Math.pow(1 - (n / length), this._decay);\r\n        }\r\n        const convolver = audioContext.createConvolver();\r\n\r\n        convolver.buffer = impulse;\r\n        this.init(convolver);\r\n    }\r\n}\r\n\r\nexport { ReverbFilter };\r\n","import { getInstance } from '../instance';\r\nimport { WebAudioUtils } from '../webaudio/WebAudioUtils';\r\nimport { Filter } from './Filter';\r\n\r\n/**\r\n * Filter for adding Stereo panning.\r\n *\r\n * @memberof filters\r\n */\r\nclass StereoFilter extends Filter\r\n{\r\n    /** The stereo panning node */\r\n    private _stereo: StereoPannerNode;\r\n\r\n    /** The stereo panning node */\r\n    private _panner: PannerNode;\r\n\r\n    /** The amount of panning, -1 is left, 1 is right, 0 is centered */\r\n    private _pan: number;\r\n\r\n    /** @param pan - The amount of panning, -1 is left, 1 is right, 0 is centered. */\r\n    constructor(pan = 0)\r\n    {\r\n        let stereo: StereoPannerNode;\r\n        let panner: PannerNode;\r\n        let destination: AudioNode;\r\n\r\n        if (!getInstance().useLegacy)\r\n        {\r\n            const { audioContext } = getInstance().context;\r\n\r\n            if (audioContext.createStereoPanner)\r\n            {\r\n                stereo = audioContext.createStereoPanner();\r\n                destination = stereo;\r\n            }\r\n            else\r\n            {\r\n                panner = audioContext.createPanner();\r\n                panner.panningModel = 'equalpower';\r\n                destination = panner;\r\n            }\r\n        }\r\n\r\n        super(destination);\r\n\r\n        this._stereo = stereo;\r\n        this._panner = panner;\r\n\r\n        this.pan = pan;\r\n    }\r\n\r\n    /** Set the amount of panning, where -1 is left, 1 is right, and 0 is centered */\r\n    set pan(value: number)\r\n    {\r\n        this._pan = value;\r\n        if (this._stereo)\r\n        {\r\n            WebAudioUtils.setParamValue(this._stereo.pan, value);\r\n        }\r\n        else if (this._panner)\r\n        {\r\n            this._panner.setPosition(value, 0, 1 - Math.abs(value));\r\n        }\r\n    }\r\n    get pan(): number\r\n    {\r\n        return this._pan;\r\n    }\r\n\r\n    public destroy(): void\r\n    {\r\n        super.destroy();\r\n        this._stereo = null;\r\n        this._panner = null;\r\n    }\r\n}\r\n\r\nexport { StereoFilter };\r\n","import { getInstance } from '../instance';\r\nimport { Filter } from './Filter';\r\n\r\n/**\r\n * Export a MediaStream to be recorded\r\n *\r\n * @memberof filters\r\n */\r\nclass StreamFilter extends Filter\r\n{\r\n    private _stream: MediaStream;\r\n\r\n    constructor()\r\n    {\r\n        let destination: MediaStreamAudioDestinationNode;\r\n        let source: MediaStreamAudioSourceNode;\r\n\r\n        if (!getInstance().useLegacy)\r\n        {\r\n            const { audioContext } = getInstance().context;\r\n\r\n            destination = audioContext.createMediaStreamDestination();\r\n            source = audioContext.createMediaStreamSource(destination.stream);\r\n        }\r\n\r\n        super(destination, source);\r\n        this._stream = destination?.stream;\r\n    }\r\n\r\n    public get stream(): MediaStream\r\n    {\r\n        return this._stream;\r\n    }\r\n\r\n    public destroy(): void\r\n    {\r\n        this._stream = null;\r\n        super.destroy();\r\n    }\r\n}\r\n\r\nexport { StreamFilter };\r\n","import { getInstance } from '../instance';\r\nimport { WebAudioUtils } from '../webaudio/WebAudioUtils';\r\nimport { Filter } from './Filter';\r\n\r\n/**\r\n * Creates a telephone-sound filter.\r\n *\r\n * @memberof filters\r\n */\r\nclass TelephoneFilter extends Filter\r\n{\r\n    constructor()\r\n    {\r\n        let destination: AudioNode;\r\n        let source: AudioNode;\r\n\r\n        if (!getInstance().useLegacy)\r\n        {\r\n            const { audioContext } = getInstance().context;\r\n            const lpf1 = audioContext.createBiquadFilter();\r\n            const lpf2 = audioContext.createBiquadFilter();\r\n            const hpf1 = audioContext.createBiquadFilter();\r\n            const hpf2 = audioContext.createBiquadFilter();\r\n\r\n            lpf1.type = 'lowpass';\r\n            WebAudioUtils.setParamValue(lpf1.frequency, 2000.0);\r\n\r\n            lpf2.type = 'lowpass';\r\n            WebAudioUtils.setParamValue(lpf2.frequency, 2000.0);\r\n\r\n            hpf1.type = 'highpass';\r\n            WebAudioUtils.setParamValue(hpf1.frequency, 500.0);\r\n\r\n            hpf2.type = 'highpass';\r\n            WebAudioUtils.setParamValue(hpf2.frequency, 500.0);\r\n\r\n            lpf1.connect(lpf2);\r\n            lpf2.connect(hpf1);\r\n            hpf1.connect(hpf2);\r\n\r\n            destination = lpf1;\r\n            source = hpf2;\r\n        }\r\n\r\n        super(destination, source);\r\n    }\r\n}\r\n\r\nexport { TelephoneFilter };\r\n","import { EventEmitter } from 'pixi.js';\r\nimport { Filter } from '../filters/Filter';\r\nimport { IMediaContext } from '../interfaces/IMediaContext';\r\n\r\n/**\r\n * The fallback version of WebAudioContext which uses `<audio>` instead of WebAudio API.\r\n * @memberof htmlaudio\r\n * @extends PIXI.EventEmitter\r\n */\r\nclass HTMLAudioContext extends EventEmitter implements IMediaContext\r\n{\r\n    /** Current global speed from 0 to 1 */\r\n    public speed = 1;\r\n\r\n    /** Current muted status of the context */\r\n    public muted = false;\r\n\r\n    /** Current volume from 0 to 1  */\r\n    public volume = 1;\r\n\r\n    /** Current paused status */\r\n    public paused = false;\r\n\r\n    /** Internal trigger when volume, mute or speed changes */\r\n    public refresh(): void\r\n    {\r\n        this.emit('refresh');\r\n    }\r\n\r\n    /** Internal trigger paused changes */\r\n    public refreshPaused(): void\r\n    {\r\n        this.emit('refreshPaused');\r\n    }\r\n\r\n    /**\r\n     * HTML Audio does not support filters, this is non-functional API.\r\n     */\r\n    public get filters(): Filter[]\r\n    {\r\n        console.warn('HTML Audio does not support filters');\r\n\r\n        return null;\r\n    }\r\n    public set filters(_filters: Filter[])\r\n    {\r\n        console.warn('HTML Audio does not support filters');\r\n    }\r\n\r\n    /**\r\n     * HTML Audio does not support `audioContext`\r\n     * @readonly\r\n     * @type {AudioContext}\r\n     */\r\n    public get audioContext(): AudioContext\r\n    {\r\n        console.warn('HTML Audio does not support audioContext');\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Toggles the muted state.\r\n     * @return The current muted state.\r\n     */\r\n    public toggleMute(): boolean\r\n    {\r\n        this.muted = !this.muted;\r\n        this.refresh();\r\n\r\n        return this.muted;\r\n    }\r\n\r\n    /**\r\n     * Toggles the paused state.\r\n     * @return The current paused state.\r\n     */\r\n    public togglePause(): boolean\r\n    {\r\n        this.paused = !this.paused;\r\n        this.refreshPaused();\r\n\r\n        return this.paused;\r\n    }\r\n\r\n    /** Destroy and don't use after this */\r\n    public destroy(): void\r\n    {\r\n        this.removeAllListeners();\r\n    }\r\n}\r\n\r\nexport { HTMLAudioContext };\r\n","import { EventEmitter, Ticker } from 'pixi.js';\r\nimport { Filter } from '../filters/Filter';\r\nimport { IMediaInstance } from '../interfaces/IMediaInstance';\r\nimport { PlayOptions } from '../Sound';\r\nimport { HTMLAudioMedia } from './HTMLAudioMedia';\r\n\r\nlet id = 0;\r\n\r\n/**\r\n * Instance which wraps the `<audio>` element playback.\r\n * @memberof htmlaudio\r\n * @extends PIXI.EventEmitter\r\n */\r\nclass HTMLAudioInstance extends EventEmitter implements IMediaInstance\r\n{\r\n    /** Extra padding, in seconds, to deal with low-latecy of HTMLAudio. */\r\n    public static readonly PADDING: number = 0.1;\r\n\r\n    /** The current unique ID for this instance. */\r\n    public readonly id: number;\r\n\r\n    /** The instance of the Audio element. */\r\n    private _source: HTMLAudioElement;\r\n\r\n    /** The instance of the Audio media element. */\r\n    private _media: HTMLAudioMedia;\r\n\r\n    /** Playback rate, where 1 is 100%. */\r\n    private _end: number;\r\n\r\n    /** Current instance paused state. */\r\n    private _paused: boolean;\r\n\r\n    /** Current instance muted state. */\r\n    private _muted: boolean;\r\n\r\n    /** Current actual paused state. */\r\n    private _pausedReal: boolean;\r\n\r\n    /** Total length of the audio. */\r\n    private _duration: number;\r\n\r\n    /** Playback rate, where 1 is 100%. */\r\n    private _start: number;\r\n\r\n    /** `true` if the audio is actually playing. */\r\n    private _playing: boolean;\r\n\r\n    /** Volume for the instance. */\r\n    private _volume: number;\r\n\r\n    /** Speed for the instance. */\r\n    private _speed: number;\r\n\r\n    /** `true` for looping the playback */\r\n    private _loop: boolean;\r\n\r\n    /** @param parent - Parent element */\r\n    constructor(parent: HTMLAudioMedia)\r\n    {\r\n        super();\r\n\r\n        this.id = id++;\r\n\r\n        this.init(parent);\r\n    }\r\n\r\n    /**\r\n     * Set a property by name, this makes it easy to chain values\r\n     * @param name - Name of the property to set\r\n     * @param value - Value to set property to\r\n     */\r\n    public set(name: 'speed' | 'volume' | 'muted' | 'loop' | 'paused', value: number | boolean): this\r\n    {\r\n        if (this[name] === undefined)\r\n        {\r\n            throw new Error(`Property with name ${name} does not exist.`);\r\n        }\r\n        else\r\n        {\r\n            switch (name)\r\n            {\r\n                case 'speed': this.speed = value as number; break;\r\n                case 'volume': this.volume = value as number; break;\r\n                case 'paused': this.paused = value as boolean; break;\r\n                case 'loop': this.loop = value as boolean; break;\r\n                case 'muted': this.muted = value as boolean; break;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /** The current playback progress from 0 to 1. */\r\n    public get progress(): number\r\n    {\r\n        const { currentTime } = this._source;\r\n\r\n        return currentTime / this._duration;\r\n    }\r\n\r\n    /** Pauses the sound. */\r\n    public get paused(): boolean\r\n    {\r\n        return this._paused;\r\n    }\r\n    public set paused(paused: boolean)\r\n    {\r\n        this._paused = paused;\r\n        this.refreshPaused();\r\n    }\r\n\r\n    /**\r\n     * Reference: http://stackoverflow.com/a/40370077\r\n     * @private\r\n     */\r\n    private _onPlay(): void\r\n    {\r\n        this._playing = true;\r\n    }\r\n\r\n    /**\r\n     * Reference: http://stackoverflow.com/a/40370077\r\n     * @private\r\n     */\r\n    private _onPause(): void\r\n    {\r\n        this._playing = false;\r\n    }\r\n\r\n    /**\r\n     * Initialize the instance.\r\n     * @param {htmlaudio.HTMLAudioMedia} media - Same as constructor\r\n     */\r\n    public init(media: HTMLAudioMedia): void\r\n    {\r\n        this._playing = false;\r\n        this._duration = media.source.duration;\r\n        const source = this._source = media.source.cloneNode(false) as HTMLAudioElement;\r\n\r\n        source.src = media.parent.url;\r\n        source.onplay = this._onPlay.bind(this);\r\n        source.onpause = this._onPause.bind(this);\r\n        media.context.on('refresh', this.refresh, this);\r\n        media.context.on('refreshPaused', this.refreshPaused, this);\r\n        this._media = media;\r\n    }\r\n\r\n    /**\r\n     * Stop the sound playing\r\n     * @private\r\n     */\r\n    private _internalStop(): void\r\n    {\r\n        if (this._source && this._playing)\r\n        {\r\n            this._source.onended = null;\r\n            this._source.pause();\r\n        }\r\n    }\r\n\r\n    /** Stop the sound playing */\r\n    public stop(): void\r\n    {\r\n        this._internalStop();\r\n\r\n        if (this._source)\r\n        {\r\n            this.emit('stop');\r\n        }\r\n    }\r\n\r\n    /** Set the instance speed from 0 to 1 */\r\n    public get speed(): number\r\n    {\r\n        return this._speed;\r\n    }\r\n    public set speed(speed: number)\r\n    {\r\n        this._speed = speed;\r\n        this.refresh();\r\n    }\r\n\r\n    /** Get the set the volume for this instance from 0 to 1 */\r\n    public get volume(): number\r\n    {\r\n        return this._volume;\r\n    }\r\n    public set volume(volume: number)\r\n    {\r\n        this._volume = volume;\r\n        this.refresh();\r\n    }\r\n\r\n    /** If the sound instance should loop playback */\r\n    public get loop(): boolean\r\n    {\r\n        return this._loop;\r\n    }\r\n    public set loop(loop: boolean)\r\n    {\r\n        this._loop = loop;\r\n        this.refresh();\r\n    }\r\n\r\n    /** `true` if the sound is muted */\r\n    public get muted(): boolean\r\n    {\r\n        return this._muted;\r\n    }\r\n    public set muted(muted: boolean)\r\n    {\r\n        this._muted = muted;\r\n        this.refresh();\r\n    }\r\n\r\n    /**\r\n     * HTML Audio does not support filters, this is non-functional API.\r\n     */\r\n    public get filters(): Filter[]\r\n    {\r\n        console.warn('HTML Audio does not support filters');\r\n\r\n        return null;\r\n    }\r\n    public set filters(_filters: Filter[])\r\n    {\r\n        console.warn('HTML Audio does not support filters');\r\n    }\r\n\r\n    /** Call whenever the loop, speed or volume changes */\r\n    public refresh(): void\r\n    {\r\n        const global = this._media.context;\r\n        const sound = this._media.parent;\r\n\r\n        // Update the looping\r\n        this._source.loop = this._loop || sound.loop;\r\n\r\n        // Update the volume\r\n        const globalVolume = global.volume * (global.muted ? 0 : 1);\r\n        const soundVolume = sound.volume * (sound.muted ? 0 : 1);\r\n        const instanceVolume = this._volume * (this._muted ? 0 : 1);\r\n\r\n        this._source.volume = instanceVolume * globalVolume * soundVolume;\r\n\r\n        // Update the speed\r\n        this._source.playbackRate = this._speed * global.speed * sound.speed;\r\n    }\r\n\r\n    /** Handle changes in paused state, either globally or sound or instance */\r\n    public refreshPaused(): void\r\n    {\r\n        const global = this._media.context;\r\n        const sound = this._media.parent;\r\n\r\n        // Handle the paused state\r\n        const pausedReal = this._paused || sound.paused || global.paused;\r\n\r\n        if (pausedReal !== this._pausedReal)\r\n        {\r\n            this._pausedReal = pausedReal;\r\n\r\n            if (pausedReal)\r\n            {\r\n                this._internalStop();\r\n\r\n                /**\r\n                 * The sound is paused.\r\n                 * @event paused\r\n                 */\r\n                this.emit('paused');\r\n            }\r\n            else\r\n            {\r\n                /**\r\n                 * The sound is unpaused.\r\n                 * @event resumed\r\n                 */\r\n                this.emit('resumed');\r\n\r\n                // resume the playing with offset\r\n                this.play({\r\n                    start: this._source.currentTime,\r\n                    end: this._end,\r\n                    volume: this._volume,\r\n                    speed: this._speed,\r\n                    loop: this._loop,\r\n                });\r\n            }\r\n\r\n            /**\r\n             * The sound is paused or unpaused.\r\n             * @event pause\r\n             * @property {boolean} paused - If the instance was paused or not.\r\n             */\r\n            this.emit('pause', pausedReal);\r\n        }\r\n    }\r\n\r\n    /** Start playing the sound/ */\r\n    public play(options: PlayOptions): void\r\n    {\r\n        const { start, end, speed, loop, volume, muted } = options;\r\n\r\n        if (end)\r\n        {\r\n            // eslint-disable-next-line no-console\r\n            console.assert(end > start, 'End time is before start time');\r\n        }\r\n\r\n        this._speed = speed;\r\n        this._volume = volume;\r\n        this._loop = !!loop;\r\n        this._muted = muted;\r\n        this.refresh();\r\n\r\n        // WebAudio doesn't support looping when a duration is set\r\n        // we'll set this just for the heck of it\r\n        if (this.loop && end !== null)\r\n        {\r\n            console.warn('Looping not support when specifying an \"end\" time');\r\n            this.loop = false;\r\n        }\r\n\r\n        this._start = start;\r\n        this._end = end || this._duration;\r\n\r\n        // Lets expand the start and end a little\r\n        // to deal with the low-latecy of playing audio this way\r\n        // this is a little fudge-factor\r\n        this._start = Math.max(0, this._start - HTMLAudioInstance.PADDING);\r\n        this._end = Math.min(this._end + HTMLAudioInstance.PADDING, this._duration);\r\n\r\n        this._source.onloadedmetadata = () =>\r\n        {\r\n            if (this._source)\r\n            {\r\n                this._source.currentTime = start;\r\n                this._source.onloadedmetadata = null;\r\n                this.emit('progress', start / this._duration, this._duration);\r\n                Ticker.shared.add(this._onUpdate, this);\r\n            }\r\n        };\r\n        this._source.onended = this._onComplete.bind(this);\r\n        this._source.play();\r\n\r\n        /**\r\n         * The sound is started.\r\n         * @event start\r\n         */\r\n        this.emit('start');\r\n    }\r\n\r\n    /**\r\n     * Handle time update on sound.\r\n     * @private\r\n     */\r\n    private _onUpdate(): void\r\n    {\r\n        this.emit('progress', this.progress, this._duration);\r\n        if (this._source.currentTime >= this._end && !this._source.loop)\r\n        {\r\n            this._onComplete();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Callback when completed.\r\n     * @private\r\n     */\r\n    private _onComplete(): void\r\n    {\r\n        Ticker.shared.remove(this._onUpdate, this);\r\n        this._internalStop();\r\n        this.emit('progress', 1, this._duration);\r\n        /**\r\n         * The sound ends, don't use after this\r\n         * @event end\r\n         */\r\n        this.emit('end', this);\r\n    }\r\n\r\n    /** Don't use after this. */\r\n    public destroy(): void\r\n    {\r\n        Ticker.shared.remove(this._onUpdate, this);\r\n        this.removeAllListeners();\r\n\r\n        const source = this._source;\r\n\r\n        if (source)\r\n        {\r\n            // Remove the listeners\r\n            source.onended = null;\r\n            source.onplay = null;\r\n            source.onpause = null;\r\n\r\n            this._internalStop();\r\n        }\r\n\r\n        this._source = null;\r\n        this._speed = 1;\r\n        this._volume = 1;\r\n        this._loop = false;\r\n        this._end = null;\r\n        this._start = 0;\r\n        this._duration = 0;\r\n        this._playing = false;\r\n        this._pausedReal = false;\r\n        this._paused = false;\r\n        this._muted = false;\r\n\r\n        if (this._media)\r\n        {\r\n            this._media.context.off('refresh', this.refresh, this);\r\n            this._media.context.off('refreshPaused', this.refreshPaused, this);\r\n            this._media = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * To string method for instance.\r\n     * @return The string representation of instance.\r\n     */\r\n    public toString(): string\r\n    {\r\n        return `[HTMLAudioInstance id=${this.id}]`;\r\n    }\r\n}\r\n\r\nexport { HTMLAudioInstance };\r\n","import { EventEmitter } from 'pixi.js';\r\nimport { Filter } from '../filters/Filter';\r\nimport { IMedia } from '../interfaces/IMedia';\r\nimport { LoadedCallback, Sound } from '../Sound';\r\nimport { HTMLAudioContext } from './HTMLAudioContext';\r\nimport { HTMLAudioInstance } from './HTMLAudioInstance';\r\n\r\n/**\r\n * The fallback version of Sound which uses `<audio>` instead of WebAudio API.\r\n * @memberof htmlaudio\r\n * @extends PIXI.EventEmitter\r\n */\r\nclass HTMLAudioMedia extends EventEmitter implements IMedia\r\n{\r\n    public parent: Sound;\r\n    private _source: HTMLAudioElement;\r\n\r\n    public init(parent: Sound): void\r\n    {\r\n        this.parent = parent;\r\n        this._source = parent.options.source as HTMLAudioElement || new Audio();\r\n        if (parent.url)\r\n        {\r\n            this._source.src = parent.url;\r\n        }\r\n    }\r\n\r\n    // Implement create\r\n    public create(): HTMLAudioInstance\r\n    {\r\n        return new HTMLAudioInstance(this);\r\n    }\r\n\r\n    /**\r\n     * If the audio media is playable (ready).\r\n     * @readonly\r\n     */\r\n    public get isPlayable(): boolean\r\n    {\r\n        return !!this._source && this._source.readyState === 4;\r\n    }\r\n\r\n    /**\r\n     * THe duration of the media in seconds.\r\n     * @readonly\r\n     */\r\n    public get duration(): number\r\n    {\r\n        return this._source.duration;\r\n    }\r\n\r\n    /**\r\n     * Reference to the context.\r\n     * @readonly\r\n     */\r\n    public get context(): HTMLAudioContext\r\n    {\r\n        return this.parent.context as HTMLAudioContext;\r\n    }\r\n\r\n    /** The collection of filters, does not apply to HTML Audio. */\r\n    public get filters(): Filter[]\r\n    {\r\n        return null;\r\n    }\r\n    public set filters(_filters: Filter[])\r\n    {\r\n        console.warn('HTML Audio does not support filters');\r\n    }\r\n\r\n    // Override the destroy\r\n    public destroy(): void\r\n    {\r\n        this.removeAllListeners();\r\n\r\n        this.parent = null;\r\n\r\n        if (this._source)\r\n        {\r\n            this._source.src = '';\r\n            this._source.load();\r\n            this._source = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the audio source element.\r\n     * @type {HTMLAudioElement}\r\n     * @readonly\r\n     */\r\n    public get source(): HTMLAudioElement\r\n    {\r\n        return this._source;\r\n    }\r\n\r\n    // Implement the method to being preloading\r\n    public load(callback?: LoadedCallback): void\r\n    {\r\n        const source = this._source;\r\n        const sound = this.parent;\r\n\r\n        // See if the source is already loaded\r\n        if (source.readyState === 4)\r\n        {\r\n            sound.isLoaded = true;\r\n            const instance = sound.autoPlayStart();\r\n\r\n            if (callback)\r\n            {\r\n                setTimeout(() =>\r\n                {\r\n                    callback(null, sound, instance);\r\n                }, 0);\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        // If there's no source, we cannot load\r\n        if (!sound.url)\r\n        {\r\n            callback(new Error('sound.url or sound.source must be set'));\r\n\r\n            return;\r\n        }\r\n\r\n        // Set the source\r\n        source.src = sound.url;\r\n\r\n        const onLoad = () =>\r\n        {\r\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\r\n            removeListeners();\r\n            sound.isLoaded = true;\r\n            const instance = sound.autoPlayStart();\r\n\r\n            if (callback)\r\n            {\r\n                callback(null, sound, instance);\r\n            }\r\n        };\r\n\r\n        const onAbort = () =>\r\n        {\r\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\r\n            removeListeners();\r\n            if (callback)\r\n            {\r\n                callback(new Error('Sound loading has been aborted'));\r\n            }\r\n        };\r\n\r\n        const onError = () =>\r\n        {\r\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\r\n            removeListeners();\r\n            const message = `Failed to load audio element (code: ${source.error.code})`;\r\n\r\n            if (callback)\r\n            {\r\n                callback(new Error(message));\r\n            }\r\n            else\r\n            {\r\n                console.error(message);\r\n            }\r\n        };\r\n\r\n        // Remove all event listeners\r\n        const removeListeners = () =>\r\n        {\r\n            // Listen for callback\r\n            source.removeEventListener('canplaythrough', onLoad);\r\n            source.removeEventListener('load', onLoad);\r\n            source.removeEventListener('abort', onAbort);\r\n            source.removeEventListener('error', onError);\r\n        };\r\n\r\n        // Listen for callback\r\n        source.addEventListener('canplaythrough', onLoad, false);\r\n        source.addEventListener('load', onLoad, false);\r\n        source.addEventListener('abort', onAbort, false);\r\n        source.addEventListener('error', onError, false);\r\n\r\n        // Begin the loading\r\n        source.load();\r\n    }\r\n}\r\n\r\nexport { HTMLAudioMedia };\r\n","import { IMediaInstance } from './interfaces';\r\nimport { CompleteCallback, Sound } from './Sound';\r\n\r\n/** Data for adding new sound sprites. */\r\ninterface SoundSpriteData\r\n{\r\n    /** The start time in seconds. */\r\n    start: number;\r\n    /** The end time in seconds. */\r\n    end: number;\r\n    /** The optional speed, if not speed, uses the default speed of the parent. */\r\n    speed?: number;\r\n}\r\n\r\n// Collection of sound sprites\r\ntype SoundSprites = Record<string, SoundSprite>;\r\n\r\n/**\r\n * Object that represents a single Sound's sprite. To add sound sprites\r\n * use the {@link Sound#addSprites} method.\r\n * @example\r\n * import { sound } from '@pixi/sound';\r\n * sound.add('alias', {\r\n *   url: 'path/to/file.ogg',\r\n *   sprites: {\r\n *     blast: { start: 0, end: 0.2 },\r\n *     boom: { start: 0.3, end: 0.5 },\r\n *   },\r\n *   loaded() {\r\n *     sound.play('alias', 'blast');\r\n *   }\r\n * );\r\n *\r\n */\r\nclass SoundSprite\r\n{\r\n    /**\r\n     * The reference sound\r\n     * @readonly\r\n     */\r\n    public parent: Sound;\r\n\r\n    /**\r\n     * The starting location in seconds.\r\n     * @readonly\r\n     */\r\n    public start: number;\r\n\r\n    /**\r\n     * The ending location in seconds\r\n     * @readonly\r\n     */\r\n    public end: number;\r\n\r\n    /**\r\n     * The speed override where 1 is 100% speed playback.\r\n     * @readonly\r\n     */\r\n    public speed: number;\r\n\r\n    /**\r\n     * The duration of the sound in seconds.\r\n     * @readonly\r\n     */\r\n    public duration: number;\r\n\r\n    /**\r\n     * Whether to loop the sound sprite.\r\n     * @readonly\r\n     */\r\n    public loop: boolean;\r\n\r\n    /**\r\n     * @param parent - The parent sound\r\n     * @param options - Data associated with object.\r\n     */\r\n    constructor(parent: Sound, options: SoundSpriteData)\r\n    {\r\n        this.parent = parent;\r\n        Object.assign(this, options);\r\n        this.duration = this.end - this.start;\r\n\r\n        // eslint-disable-next-line no-console\r\n        console.assert(this.duration > 0, 'End time must be after start time');\r\n    }\r\n\r\n    /**\r\n     * Play the sound sprite.\r\n     * @param {Function} [complete] - Function call when complete\r\n     * @return Sound instance being played.\r\n     */\r\n    public play(complete?: CompleteCallback): IMediaInstance | Promise<IMediaInstance>\r\n    {\r\n        return this.parent.play({\r\n            complete,\r\n            speed: this.speed || this.parent.speed,\r\n            end: this.end,\r\n            start: this.start,\r\n            loop: this.loop\r\n        });\r\n    }\r\n\r\n    /** Destroy and don't use after this */\r\n    public destroy(): void\r\n    {\r\n        this.parent = null;\r\n    }\r\n}\r\n\r\nexport type { SoundSpriteData, SoundSprites };\r\nexport { SoundSprite };\r\n","type ExtensionMap = Record<string, boolean>;\r\n\r\n/**\r\n * The list of extensions that can be played. This is the preferred order of playback.\r\n * If you want to priority the order of playback, you can use this array to do so.\r\n * @readonly\r\n * @memberof utils\r\n */\r\nconst extensions: string[] = [\r\n    'ogg',\r\n    'oga',\r\n    'opus',\r\n    'm4a',\r\n    'mp3',\r\n    'mpeg',\r\n    'wav',\r\n    'aiff',\r\n    'wma',\r\n    'mid',\r\n    'caf',\r\n];\r\n\r\nconst mimes: string[] = [\r\n    'audio/mpeg',\r\n    'audio/ogg',\r\n];\r\n\r\n/**\r\n * The list of browser supported audio formats.\r\n * @readonly\r\n * @memberof utils\r\n * @property {boolean} mp3 - `true` if file-type is supported\r\n * @property {boolean} ogg - `true` if file-type is supported\r\n * @property {boolean} oga - `true` if file-type is supported\r\n * @property {boolean} opus - `true` if file-type is supported\r\n * @property {boolean} mpeg - `true` if file-type is supported\r\n * @property {boolean} wav - `true` if file-type is supported\r\n * @property {boolean} aiff - `true` if file-type is supported\r\n * @property {boolean} wma - `true` if file-type is supported\r\n * @property {boolean} mid - `true` if file-type is supported\r\n * @property {boolean} caf - `true` if file-type is supported. Note that for this we check if the\r\n *                             'opus' codec is supported inside the caf container.\r\n */\r\nconst supported: ExtensionMap = {};\r\n\r\n/**\r\n * Function to validate file type formats. This is called when the library initializes, but can\r\n * be called again if you need to recognize a format not listed in `utils.extensions` at\r\n * initialization.\r\n * @memberof utils\r\n * @param typeOverrides - - Dictionary of type overrides (inputs for\r\n *                                 AudioElement.canPlayType()), keyed by extension from the\r\n *                                 utils.extensions array.\r\n */\r\nfunction validateFormats(typeOverrides?: Record<string, string>): void\r\n{\r\n    const overrides: Record<string, string> = {\r\n        m4a: 'audio/mp4',\r\n        oga: 'audio/ogg',\r\n        opus: 'audio/ogg; codecs=\"opus\"',\r\n        caf: 'audio/x-caf; codecs=\"opus\"', ...(typeOverrides || {})\r\n    };\r\n    const audio = document.createElement('audio');\r\n    const formats: ExtensionMap = {};\r\n    const no = /^no$/;\r\n\r\n    extensions.forEach((ext) =>\r\n    {\r\n        const canByExt = audio.canPlayType(`audio/${ext}`).replace(no, '');\r\n        const canByType = overrides[ext] ? audio.canPlayType(overrides[ext]).replace(no, '') : '';\r\n\r\n        formats[ext] = !!canByExt || !!canByType;\r\n    });\r\n    Object.assign(supported, formats);\r\n}\r\n\r\n// initialize supported\r\nvalidateFormats();\r\n\r\nexport {\r\n    extensions,\r\n    mimes,\r\n    supported,\r\n    validateFormats,\r\n};\r\n","import { EventEmitter, Ticker } from 'pixi.js';\r\nimport { Filter } from '../filters/Filter';\r\nimport { IMediaInstance } from '../interfaces';\r\nimport { PlayOptions } from '../Sound';\r\nimport { WebAudioMedia } from './WebAudioMedia';\r\nimport { WebAudioUtils } from './WebAudioUtils';\r\n\r\nlet id = 0;\r\n\r\n/**\r\n * A single play instance that handles the AudioBufferSourceNode.\r\n * @memberof webaudio\r\n * @extends PIXI.EventEmitter\r\n */\r\nclass WebAudioInstance extends EventEmitter implements IMediaInstance\r\n{\r\n    /**\r\n     * The current unique ID for this instance.\r\n     * @readonly\r\n     */\r\n    public readonly id: number;\r\n\r\n    /** The source Sound. */\r\n    private _media: WebAudioMedia;\r\n\r\n    /** true if paused. */\r\n    private _paused: boolean;\r\n\r\n    /** true if muted. */\r\n    private _muted: boolean;\r\n\r\n    /** true if paused. */\r\n    private _pausedReal: boolean;\r\n\r\n    /** The instance volume */\r\n    private _volume: number;\r\n\r\n    /** Last update frame number. */\r\n    private _lastUpdate: number;\r\n\r\n    /** The total number of seconds elapsed in playback. */\r\n    private _elapsed: number;\r\n\r\n    /** Playback rate, where 1 is 100%. */\r\n    private _speed: number;\r\n\r\n    /** Playback rate, where 1 is 100%. */\r\n    private _end: number;\r\n\r\n    /** `true` if should be looping. */\r\n    private _loop: boolean;\r\n\r\n    /** Gain node for controlling volume of instance */\r\n    private _gain: GainNode;\r\n\r\n    /** Length of the sound in seconds. */\r\n    private _duration: number;\r\n\r\n    /** The progress of the sound from 0 to 1. */\r\n    private _progress: number;\r\n\r\n    /** Audio buffer source clone from Sound object. */\r\n    private _source: AudioBufferSourceNode;\r\n\r\n    /** The filters */\r\n    private _filters: Filter[];\r\n\r\n    constructor(media: WebAudioMedia)\r\n    {\r\n        super();\r\n\r\n        this.id = id++;\r\n        this._media = null;\r\n        this._paused = false;\r\n        this._muted = false;\r\n        this._elapsed = 0;\r\n\r\n        // Initialize\r\n        this.init(media);\r\n    }\r\n\r\n    /**\r\n     * Set a property by name, this makes it easy to chain values\r\n     * @param name - Name of the property to set.\r\n     * @param value - Value to set property to.\r\n     */\r\n    public set(name: 'speed' | 'volume' | 'muted' | 'loop' | 'paused', value: number | boolean): this\r\n    {\r\n        if (this[name] === undefined)\r\n        {\r\n            throw new Error(`Property with name ${name} does not exist.`);\r\n        }\r\n        else\r\n        {\r\n            switch (name)\r\n            {\r\n                case 'speed': this.speed = value as number; break;\r\n                case 'volume': this.volume = value as number; break;\r\n                case 'muted': this.muted = value as boolean; break;\r\n                case 'loop': this.loop = value as boolean; break;\r\n                case 'paused': this.paused = value as boolean; break;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Stops the instance, don't use after this. */\r\n    public stop(): void\r\n    {\r\n        if (this._source)\r\n        {\r\n            this._internalStop();\r\n            this.emit('stop');\r\n        }\r\n    }\r\n\r\n    /** Set the instance speed from 0 to 1 */\r\n    public get speed(): number\r\n    {\r\n        return this._speed;\r\n    }\r\n    public set speed(speed: number)\r\n    {\r\n        this._speed = speed;\r\n        this.refresh();\r\n        this._update(true); // update progress\r\n    }\r\n\r\n    /** Get the set the volume for this instance from 0 to 1 */\r\n    public get volume(): number\r\n    {\r\n        return this._volume;\r\n    }\r\n    public set volume(volume: number)\r\n    {\r\n        this._volume = volume;\r\n        this.refresh();\r\n    }\r\n\r\n    /** `true` if the sound is muted */\r\n    public get muted(): boolean\r\n    {\r\n        return this._muted;\r\n    }\r\n    public set muted(muted: boolean)\r\n    {\r\n        this._muted = muted;\r\n        this.refresh();\r\n    }\r\n\r\n    /** If the sound instance should loop playback */\r\n    public get loop(): boolean\r\n    {\r\n        return this._loop;\r\n    }\r\n    public set loop(loop: boolean)\r\n    {\r\n        this._loop = loop;\r\n        this.refresh();\r\n    }\r\n\r\n    /** The collection of filters. */\r\n    public get filters(): Filter[]\r\n    {\r\n        return this._filters;\r\n    }\r\n    public set filters(filters: Filter[])\r\n    {\r\n        if (this._filters)\r\n        {\r\n            this._filters?.filter((filter) => filter).forEach((filter) => filter.disconnect());\r\n            this._filters = null;\r\n            // Reconnect direct path\r\n            this._source.connect(this._gain);\r\n        }\r\n        this._filters = filters?.length ? filters.slice(0) : null;\r\n        this.refresh();\r\n    }\r\n\r\n    /** Refresh loop, volume and speed based on changes to parent */\r\n    public refresh(): void\r\n    {\r\n        // Sound could be paused\r\n        if (!this._source)\r\n        {\r\n            return;\r\n        }\r\n        const global = this._media.context;\r\n        const sound = this._media.parent;\r\n\r\n        // Updating looping\r\n        this._source.loop = this._loop || sound.loop;\r\n\r\n        // Update the volume\r\n        const globalVolume = global.volume * (global.muted ? 0 : 1);\r\n        const soundVolume = sound.volume * (sound.muted ? 0 : 1);\r\n        const instanceVolume = this._volume * (this._muted ? 0 : 1);\r\n\r\n        WebAudioUtils.setParamValue(this._gain.gain, instanceVolume * soundVolume * globalVolume);\r\n\r\n        // Update the speed\r\n        WebAudioUtils.setParamValue(this._source.playbackRate, this._speed * sound.speed * global.speed);\r\n\r\n        this.applyFilters();\r\n    }\r\n\r\n    /** Connect filters nodes to audio context */\r\n    private applyFilters(): void\r\n    {\r\n        if (this._filters?.length)\r\n        {\r\n            // Disconnect direct path before inserting filters\r\n            this._source.disconnect();\r\n\r\n            // Connect each filter\r\n            let source: { connect: (node: AudioNode) => void } = this._source;\r\n\r\n            this._filters.forEach((filter: Filter) =>\r\n            {\r\n                source.connect(filter.destination);\r\n                source = filter;\r\n            });\r\n            source.connect(this._gain);\r\n        }\r\n    }\r\n\r\n    /** Handle changes in paused state, either globally or sound or instance */\r\n    public refreshPaused(): void\r\n    {\r\n        const global = this._media.context;\r\n        const sound = this._media.parent;\r\n\r\n        // Consider global and sound paused\r\n        const pausedReal = this._paused || sound.paused || global.paused;\r\n\r\n        if (pausedReal !== this._pausedReal)\r\n        {\r\n            this._pausedReal = pausedReal;\r\n\r\n            if (pausedReal)\r\n            {\r\n                // pause the sounds\r\n                this._internalStop();\r\n\r\n                /**\r\n                 * The sound is paused.\r\n                 * @event paused\r\n                 */\r\n                this.emit('paused');\r\n            }\r\n            else\r\n            {\r\n                /**\r\n                 * The sound is unpaused.\r\n                 * @event resumed\r\n                 */\r\n                this.emit('resumed');\r\n\r\n                // resume the playing with offset\r\n                this.play({\r\n                    start: this._elapsed % this._duration,\r\n                    end: this._end,\r\n                    speed: this._speed,\r\n                    loop: this._loop,\r\n                    volume: this._volume,\r\n                });\r\n            }\r\n\r\n            /**\r\n             * The sound is paused or unpaused.\r\n             * @event pause\r\n             * @property {boolean} paused - If the instance was paused or not.\r\n             */\r\n            this.emit('pause', pausedReal);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Plays the sound.\r\n     * @param options - Play options.\r\n     */\r\n    public play(options: PlayOptions): void\r\n    {\r\n        const { start, end, speed, loop, volume, muted, filters } = options;\r\n\r\n        if (end)\r\n        {\r\n            // eslint-disable-next-line no-console\r\n            console.assert(end > start, 'End time is before start time');\r\n        }\r\n        this._paused = false;\r\n        const { source, gain } = this._media.nodes.cloneBufferSource();\r\n\r\n        this._source = source;\r\n        this._gain = gain;\r\n        this._speed = speed;\r\n        this._volume = volume;\r\n        this._loop = !!loop;\r\n        this._muted = muted;\r\n        this._filters = filters;\r\n        this.refresh();\r\n\r\n        const duration: number = this._source.buffer.duration;\r\n\r\n        this._duration = duration;\r\n        this._end = end;\r\n        this._lastUpdate = this._now();\r\n        this._elapsed = start;\r\n        this._source.onended = this._onComplete.bind(this);\r\n\r\n        if (this._loop)\r\n        {\r\n            this._source.loopEnd = end;\r\n            this._source.loopStart = start;\r\n            this._source.start(0, start);\r\n        }\r\n        else if (end)\r\n        {\r\n            this._source.start(0, start, end - start);\r\n        }\r\n        else\r\n        {\r\n            this._source.start(0, start);\r\n        }\r\n\r\n        /**\r\n         * The sound is started.\r\n         * @event start\r\n         */\r\n        this.emit('start');\r\n\r\n        // Do an update for the initial progress\r\n        this._update(true);\r\n\r\n        // Start handling internal ticks\r\n        this.enableTicker(true);\r\n    }\r\n\r\n    /** Start the update progress. */\r\n    private enableTicker(enabled: boolean): void\r\n    {\r\n        Ticker.shared.remove(this._updateListener, this);\r\n        if (enabled)\r\n        {\r\n            Ticker.shared.add(this._updateListener, this);\r\n        }\r\n    }\r\n\r\n    /** The current playback progress from 0 to 1. */\r\n    public get progress(): number\r\n    {\r\n        return this._progress;\r\n    }\r\n\r\n    /** Pauses the sound. */\r\n    public get paused(): boolean\r\n    {\r\n        return this._paused;\r\n    }\r\n\r\n    public set paused(paused: boolean)\r\n    {\r\n        this._paused = paused;\r\n        this.refreshPaused();\r\n    }\r\n\r\n    /** Don't use after this. */\r\n    public destroy(): void\r\n    {\r\n        this.removeAllListeners();\r\n        this._internalStop();\r\n        if (this._gain)\r\n        {\r\n            this._gain.disconnect();\r\n            this._gain = null;\r\n        }\r\n        if (this._media)\r\n        {\r\n            this._media.context.events.off('refresh', this.refresh, this);\r\n            this._media.context.events.off('refreshPaused', this.refreshPaused, this);\r\n            this._media = null;\r\n        }\r\n        this._filters?.forEach((filter) => filter.disconnect());\r\n        this._filters = null;\r\n        this._end = null;\r\n        this._speed = 1;\r\n        this._volume = 1;\r\n        this._loop = false;\r\n        this._elapsed = 0;\r\n        this._duration = 0;\r\n        this._paused = false;\r\n        this._muted = false;\r\n        this._pausedReal = false;\r\n    }\r\n\r\n    /**\r\n     * To string method for instance.\r\n     * @return The string representation of instance.\r\n     */\r\n    public toString(): string\r\n    {\r\n        return `[WebAudioInstance id=${this.id}]`;\r\n    }\r\n\r\n    /**\r\n     * Get the current time in seconds.\r\n     * @return Seconds since start of context\r\n     */\r\n    private _now(): number\r\n    {\r\n        return this._media.context.audioContext.currentTime;\r\n    }\r\n\r\n    /** Callback for update listener */\r\n    private _updateListener()\r\n    {\r\n        this._update();\r\n    }\r\n\r\n    /** Internal update the progress. */\r\n    private _update(force = false): void\r\n    {\r\n        if (this._source)\r\n        {\r\n            const now: number = this._now();\r\n            const delta: number = now - this._lastUpdate;\r\n\r\n            if (delta > 0 || force)\r\n            {\r\n                const speed: number = this._source.playbackRate.value;\r\n\r\n                this._elapsed += delta * speed;\r\n                this._lastUpdate = now;\r\n                const duration: number = this._duration;\r\n                let progress: number;\r\n\r\n                if (this._source.loopStart)\r\n                {\r\n                    const soundLength = this._source.loopEnd - this._source.loopStart;\r\n\r\n                    progress = (this._source.loopStart + (this._elapsed % soundLength)) / duration;\r\n                }\r\n                else\r\n                {\r\n                    progress = (this._elapsed % duration) / duration;\r\n                }\r\n\r\n                // Update the progress\r\n                this._progress = progress;\r\n\r\n                /**\r\n                 * The sound progress is updated.\r\n                 * @event progress\r\n                 * @property {number} progress - Amount progressed from 0 to 1\r\n                 * @property {number} duration - The total playback in seconds\r\n                 */\r\n                this.emit('progress', this._progress, duration);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Initializes the instance. */\r\n    public init(media: WebAudioMedia): void\r\n    {\r\n        this._media = media;\r\n        media.context.events.on('refresh', this.refresh, this);\r\n        media.context.events.on('refreshPaused', this.refreshPaused, this);\r\n    }\r\n\r\n    /** Stops the instance. */\r\n    private _internalStop(): void\r\n    {\r\n        if (this._source)\r\n        {\r\n            this.enableTicker(false);\r\n            this._source.onended = null;\r\n            this._source.stop(0); // param needed for iOS 8 bug\r\n            this._source.disconnect();\r\n            try\r\n            {\r\n                this._source.buffer = null;\r\n            }\r\n            catch (err)\r\n            {\r\n                // try/catch workaround for bug in older Chrome versions\r\n                console.warn('Failed to set AudioBufferSourceNode.buffer to null:', err);\r\n            }\r\n            this._source = null;\r\n        }\r\n    }\r\n\r\n    /** Callback when completed. */\r\n    private _onComplete(): void\r\n    {\r\n        if (this._source)\r\n        {\r\n            this.enableTicker(false);\r\n            this._source.onended = null;\r\n            this._source.disconnect();\r\n            try\r\n            {\r\n                this._source.buffer = null;\r\n            }\r\n            catch (err)\r\n            {\r\n                // try/catch workaround for bug in older Chrome versions\r\n                console.warn('Failed to set AudioBufferSourceNode.buffer to null:', err);\r\n            }\r\n        }\r\n        this._source = null;\r\n        this._progress = 1;\r\n        this.emit('progress', 1, this._duration);\r\n        /**\r\n         * The sound ends, don't use after this\r\n         * @event end\r\n         */\r\n        this.emit('end', this);\r\n    }\r\n}\r\n\r\nexport { WebAudioInstance };\r\n","import { Filter } from './filters/Filter';\r\n\r\n/**\r\n * Abstract class which SoundNodes and SoundContext\r\n * both extend. This provides the functionality for adding\r\n * dynamic filters.\r\n */\r\nclass Filterable\r\n{\r\n    /** Get the gain node */\r\n    private _input: AudioNode;\r\n\r\n    /** The destination output audio node */\r\n    private _output: AudioNode;\r\n\r\n    /** Collection of filters. */\r\n    private _filters: Filter[];\r\n\r\n    /**\r\n     * @param input - The source audio node\r\n     * @param output - The output audio node\r\n     */\r\n    constructor(input: AudioNode, output: AudioNode)\r\n    {\r\n        this._output = output;\r\n        this._input = input;\r\n    }\r\n\r\n    /** The destination output audio node */\r\n    get destination(): AudioNode\r\n    {\r\n        return this._input;\r\n    }\r\n\r\n    /** The collection of filters. */\r\n    get filters(): Filter[]\r\n    {\r\n        return this._filters;\r\n    }\r\n    set filters(filters: Filter[])\r\n    {\r\n        if (this._filters)\r\n        {\r\n            this._filters.forEach((filter: Filter) =>\r\n            {\r\n                if (filter)\r\n                {\r\n                    filter.disconnect();\r\n                }\r\n            });\r\n            this._filters = null;\r\n            // Reconnect direct path\r\n            this._input.connect(this._output);\r\n        }\r\n\r\n        if (filters && filters.length)\r\n        {\r\n            this._filters = filters.slice(0);\r\n\r\n            // Disconnect direct path before inserting filters\r\n            this._input.disconnect();\r\n\r\n            // Connect each filter\r\n            let prevFilter: Filter = null;\r\n\r\n            filters.forEach((filter: Filter) =>\r\n            {\r\n                if (prevFilter === null)\r\n                {\r\n                    // first filter is the destination\r\n                    // for the analyser\r\n                    this._input.connect(filter.destination);\r\n                }\r\n                else\r\n                {\r\n                    prevFilter.connect(filter.destination);\r\n                }\r\n                prevFilter = filter;\r\n            });\r\n            prevFilter.connect(this._output);\r\n        }\r\n    }\r\n\r\n    /** Cleans up. */\r\n    public destroy(): void\r\n    {\r\n        this.filters = null;\r\n        this._input = null;\r\n        this._output = null;\r\n    }\r\n}\r\n\r\nexport { Filterable };\r\n","import { Filterable } from '../Filterable';\r\nimport { WebAudioContext } from './WebAudioContext';\r\nimport { WebAudioUtils } from './WebAudioUtils';\r\n\r\n/** Output for cloning source node. */\r\ninterface SourceClone\r\n{\r\n    /** Cloned audio buffer source */\r\n    source: AudioBufferSourceNode;\r\n    /** Independent volume control */\r\n    gain: GainNode;\r\n}\r\n\r\n/**\r\n * @memberof webaudio\r\n */\r\nclass WebAudioNodes extends Filterable\r\n{\r\n    /**\r\n     * The buffer size for script processor, default is `0` which auto-detects. If you plan to use\r\n     * script node on iOS, you'll need to provide a non-zero amount.\r\n     * @default 0\r\n     */\r\n    public static BUFFER_SIZE = 0;\r\n\r\n    /**\r\n     * Get the buffer source node\r\n     * @readonly\r\n     */\r\n    public bufferSource: AudioBufferSourceNode;\r\n\r\n    /**\r\n     * Get the gain node\r\n     * @readonly\r\n     */\r\n    public gain: GainNode;\r\n\r\n    /**\r\n     * Get the analyser node\r\n     * @readonly\r\n     */\r\n    public analyser: AnalyserNode;\r\n\r\n    /**\r\n     * Reference to the SoundContext\r\n     * @readonly\r\n     */\r\n    public context: WebAudioContext;\r\n\r\n    /** Private reference to the script processor node. */\r\n    private _script: ScriptProcessorNode;\r\n\r\n    /**\r\n     * @param context - The audio context.\r\n     */\r\n    constructor(context: WebAudioContext)\r\n    {\r\n        const audioContext: AudioContext = context.audioContext;\r\n\r\n        const bufferSource: AudioBufferSourceNode = audioContext.createBufferSource();\r\n        const gain: GainNode = audioContext.createGain();\r\n        const analyser: AnalyserNode = audioContext.createAnalyser();\r\n\r\n        bufferSource.connect(analyser);\r\n        analyser.connect(gain);\r\n        gain.connect(context.destination);\r\n\r\n        super(analyser, gain);\r\n\r\n        this.context = context;\r\n        this.bufferSource = bufferSource;\r\n        this.gain = gain;\r\n        this.analyser = analyser;\r\n    }\r\n\r\n    /**\r\n     * Get the script processor node.\r\n     * @readonly\r\n     */\r\n    public get script(): ScriptProcessorNode\r\n    {\r\n        if (!this._script)\r\n        {\r\n            this._script = this.context.audioContext.createScriptProcessor(WebAudioNodes.BUFFER_SIZE);\r\n            this._script.connect(this.context.destination);\r\n        }\r\n\r\n        return this._script;\r\n    }\r\n\r\n    /** Cleans up. */\r\n    public destroy(): void\r\n    {\r\n        super.destroy();\r\n\r\n        this.bufferSource.disconnect();\r\n        if (this._script)\r\n        {\r\n            this._script.disconnect();\r\n        }\r\n        this.gain.disconnect();\r\n        this.analyser.disconnect();\r\n\r\n        this.bufferSource = null;\r\n        this._script = null;\r\n        this.gain = null;\r\n        this.analyser = null;\r\n\r\n        this.context = null;\r\n    }\r\n\r\n    /**\r\n     * Clones the bufferSource. Used just before playing a sound.\r\n     * @returns {SourceClone} The clone AudioBufferSourceNode.\r\n     */\r\n    public cloneBufferSource(): SourceClone\r\n    {\r\n        const orig: AudioBufferSourceNode = this.bufferSource;\r\n        const source: AudioBufferSourceNode = this.context.audioContext.createBufferSource();\r\n\r\n        source.buffer = orig.buffer;\r\n        WebAudioUtils.setParamValue(source.playbackRate, orig.playbackRate.value);\r\n        source.loop = orig.loop;\r\n\r\n        const gain: GainNode = this.context.audioContext.createGain();\r\n\r\n        source.connect(gain);\r\n        gain.connect(this.destination);\r\n\r\n        return { source, gain };\r\n    }\r\n\r\n    /**\r\n     * Get buffer size of `ScriptProcessorNode`.\r\n     * @readonly\r\n     */\r\n    get bufferSize(): number\r\n    {\r\n        return this.script.bufferSize;\r\n    }\r\n}\r\n\r\nexport type { SourceClone };\r\nexport { WebAudioNodes };\r\n","import { DOMAdapter } from 'pixi.js';\r\nimport { Filter } from '../filters/Filter';\r\nimport { IMedia } from '../interfaces/IMedia';\r\nimport { LoadedCallback, Sound } from '../Sound';\r\nimport { WebAudioContext } from './WebAudioContext';\r\nimport { WebAudioInstance } from './WebAudioInstance';\r\nimport { WebAudioNodes } from './WebAudioNodes';\r\n\r\n/**\r\n * Represents a single sound element. Can be used to play, pause, etc. sound instances.\r\n * @memberof webaudio\r\n */\r\nclass WebAudioMedia implements IMedia\r\n{\r\n    /**\r\n     * Reference to the parent Sound container.\r\n     * @readonly\r\n     */\r\n    public parent: Sound;\r\n\r\n    /**\r\n     * The file buffer to load.\r\n     * @readonly\r\n     */\r\n    public source: ArrayBuffer | AudioBuffer;\r\n\r\n    /** Instance of the chain builder. */\r\n    private _nodes: WebAudioNodes;\r\n\r\n    /**\r\n     * Raw audio file data.\r\n     */\r\n    public file: Blob;\r\n\r\n    /** Instance of the source node. */\r\n    private _source: AudioBufferSourceNode;\r\n\r\n    /**\r\n     * Re-initialize without constructing.\r\n     * @param parent - - Instance of parent Sound container\r\n     */\r\n    public init(parent: Sound): void\r\n    {\r\n        this.parent = parent;\r\n        this._nodes = new WebAudioNodes(this.context);\r\n        this._source = this._nodes.bufferSource;\r\n        this.source = parent.options.source as ArrayBuffer | AudioBuffer;\r\n    }\r\n\r\n    /** Destructor, safer to use `SoundLibrary.remove(alias)` to remove this sound. */\r\n    public destroy(): void\r\n    {\r\n        this.parent = null;\r\n        this._nodes.destroy();\r\n        this._nodes = null;\r\n        try\r\n        {\r\n            this._source.buffer = null;\r\n        }\r\n        catch (err)\r\n        {\r\n            // try/catch workaround for bug in older Chrome versions\r\n            console.warn('Failed to set AudioBufferSourceNode.buffer to null:', err);\r\n        }\r\n        this._source = null;\r\n        this.source = null;\r\n    }\r\n\r\n    // Implement create\r\n    public create(): WebAudioInstance\r\n    {\r\n        return new WebAudioInstance(this);\r\n    }\r\n\r\n    // Implement context\r\n    public get context(): WebAudioContext\r\n    {\r\n        return this.parent.context as WebAudioContext;\r\n    }\r\n\r\n    // Implement isPlayable\r\n    public get isPlayable(): boolean\r\n    {\r\n        return !!this._source && !!this._source.buffer;\r\n    }\r\n\r\n    // Implement filters\r\n    public get filters(): Filter[]\r\n    {\r\n        return this._nodes.filters;\r\n    }\r\n    public set filters(filters: Filter[])\r\n    {\r\n        this._nodes.filters = filters;\r\n    }\r\n\r\n    // Implements duration\r\n    public get duration(): number\r\n    {\r\n        // eslint-disable-next-line no-console\r\n        console.assert(this.isPlayable, 'Sound not yet playable, no duration');\r\n\r\n        return this._source.buffer.duration;\r\n    }\r\n\r\n    /** Gets and sets the buffer. */\r\n    public get buffer(): AudioBuffer\r\n    {\r\n        return this._source.buffer;\r\n    }\r\n    public set buffer(buffer: AudioBuffer)\r\n    {\r\n        this._source.buffer = buffer;\r\n    }\r\n\r\n    /** Get the current chained nodes object */\r\n    public get nodes(): WebAudioNodes\r\n    {\r\n        return this._nodes;\r\n    }\r\n\r\n    // Implements load\r\n    public load(callback?: LoadedCallback): void\r\n    {\r\n        // Load from the arraybuffer, incase it was loaded outside\r\n        if (this.source)\r\n        {\r\n            this._decode(this.source, callback);\r\n        }\r\n        // Load from the file path\r\n        else if (this.parent.url)\r\n        {\r\n            this._loadUrl(callback);\r\n        }\r\n        else if (callback)\r\n        {\r\n            callback(new Error('sound.url or sound.source must be set'));\r\n        }\r\n        else\r\n        {\r\n            console.error('sound.url or sound.source must be set');\r\n        }\r\n    }\r\n\r\n    /** Loads a sound using XHMLHttpRequest object. */\r\n    private async _loadUrl(callback?: LoadedCallback): Promise<void>\r\n    {\r\n        const url: string = this.parent.url;\r\n        const response = await DOMAdapter.get().fetch(url);\r\n        const arrayBuffer = await response.arrayBuffer();\r\n        \r\n        this.file = new Blob([arrayBuffer]);\r\n        this._decode(arrayBuffer, callback);\r\n    }\r\n\r\n    /**\r\n     * Decodes the array buffer.\r\n     * @param arrayBuffer - From load.\r\n     * @param {Function} callback - Callback optional\r\n     */\r\n    private _decode(arrayBuffer: ArrayBuffer | AudioBuffer, callback?: LoadedCallback): void\r\n    {\r\n        const audioBufferReadyFn = (err: Error, buffer: AudioBuffer) =>\r\n        {\r\n            if (err)\r\n            {\r\n                if (callback)\r\n                {\r\n                    callback(err);\r\n                }\r\n            }\r\n            else\r\n            {\r\n                this.parent.isLoaded = true;\r\n                this.buffer = buffer;\r\n                const instance = this.parent.autoPlayStart();\r\n\r\n                if (callback)\r\n                {\r\n                    callback(null, this.parent, instance);\r\n                }\r\n            }\r\n        };\r\n\r\n        if (arrayBuffer instanceof AudioBuffer)\r\n        {\r\n            audioBufferReadyFn(null, arrayBuffer);\r\n        }\r\n        else\r\n        {\r\n            const context = this.parent.context as WebAudioContext;\r\n\r\n            context.decode(arrayBuffer, audioBufferReadyFn);\r\n        }\r\n    }\r\n}\r\n\r\nexport { WebAudioMedia };\r\n","import { path } from 'pixi.js';\r\nimport { Filter } from './filters/Filter';\r\nimport { HTMLAudioMedia } from './htmlaudio/HTMLAudioMedia';\r\nimport { getInstance } from './instance';\r\nimport { IMedia, IMediaContext, IMediaInstance } from './interfaces';\r\nimport { SoundSprite, SoundSpriteData, SoundSprites } from './SoundSprite';\r\nimport { extensions, supported } from './utils/supported';\r\nimport { WebAudioMedia } from './webaudio/WebAudioMedia';\r\n\r\n/**\r\n * Options to use for creating sounds.\r\n */\r\ninterface Options\r\n{\r\n    /**\r\n     * `true` to immediately start preloading.\r\n     * @default false\r\n     */\r\n    autoPlay?: boolean;\r\n    /**\r\n     * `true` to disallow playing multiple layered instances at once.\r\n     * @default false\r\n     */\r\n    singleInstance?: boolean;\r\n    /**\r\n     * The amount of volume 1 = 100%.\r\n     * @default 1\r\n     */\r\n    volume?: number;\r\n    /**\r\n     * The playback rate where 1 is 100% speed.\r\n     * @default 1\r\n     */\r\n    speed?: number;\r\n    /**\r\n     * Global complete callback when play is finished.\r\n     * @type {Function}\r\n     */\r\n    complete?: CompleteCallback;\r\n    /**\r\n     * Call when finished loading.\r\n     * @type {Function}\r\n     */\r\n    loaded?: LoadedCallback;\r\n    /**\r\n     * `true` to immediately start preloading if loading from `url`.\r\n     */\r\n    preload?: boolean;\r\n    /**\r\n     * Initial loop value, `true` is loop infinitely\r\n     * @default false\r\n     */\r\n    loop?: boolean;\r\n    /**\r\n     * The source of the file being loaded\r\n     */\r\n    url?: string | string[];\r\n    /**\r\n     * If sound is already preloaded, available.\r\n     */\r\n    source?: ArrayBuffer | AudioBuffer | HTMLAudioElement;\r\n    /**\r\n     * The map of sprite data. Where a sprite is an object\r\n     * with a `start` and `end`, which are the times in seconds. Optionally, can include\r\n     * a `speed` amount where 1 is 100% speed.\r\n     */\r\n    sprites?: Record<string, SoundSpriteData>;\r\n}\r\n\r\n/**\r\n * Options used for sound playback.\r\n */\r\ninterface PlayOptions\r\n{\r\n    /**\r\n     * Start time offset in seconds.\r\n     * @default 0\r\n     */\r\n    start?: number;\r\n    /**\r\n     * End time in seconds.\r\n     */\r\n    end?: number;\r\n    /**\r\n     * Override default speed, default to the Sound's speed setting.\r\n     */\r\n    speed?: number;\r\n    /**\r\n    * Override default loop, default to the Sound's loop setting.\r\n    */\r\n    loop?: boolean;\r\n    /**\r\n     * Override default volume, default to the Sound's volume setting.\r\n     */\r\n    volume?: number;\r\n    /**\r\n     * The sprite to play.\r\n     */\r\n    sprite?: string;\r\n    /**\r\n     * If sound instance is muted by default.\r\n     * @default false\r\n     */\r\n    muted?: boolean;\r\n    /**\r\n     * Filters that apply to play.\r\n     * Only supported with WebAudio.\r\n     */\r\n    filters?: Filter[];\r\n    /**\r\n     * When completed.\r\n     * @type {Function}\r\n     */\r\n    complete?: CompleteCallback;\r\n    /**\r\n     * If not already preloaded, callback when finishes load.\r\n     * @type {Function}\r\n     */\r\n    loaded?: LoadedCallback;\r\n    /**\r\n     * Setting `true` will stop any playing instances. This is the same as\r\n     * the singleInstance property on Sound, but is play-specific.\r\n     */\r\n    singleInstance?: boolean;\r\n}\r\n\r\n/**\r\n * Callback when sound is loaded.\r\n * @ignore\r\n * @param {Error} err - The callback error.\r\n * @param {Sound} sound - The instance of new sound.\r\n * @param {IMediaInstance} instance - The instance of auto-played sound.\r\n */\r\ntype LoadedCallback = (err: Error, sound?: Sound, instance?: IMediaInstance) => void;\r\n\r\n/**\r\n * Callback when sound is completed.\r\n * @ignore\r\n * @param {Sound} sound - The instance of sound.\r\n */\r\ntype CompleteCallback = (sound: Sound) => void;\r\n\r\ntype SoundSpriteDataMap = Record<string, SoundSpriteData>;\r\n\r\n/**\r\n * Sound represents a single piece of loaded media. When playing a sound {@link IMediaInstance} objects\r\n * are created. Properties such a `volume`, `pause`, `mute`, `speed`, etc will have an effect on all instances.\r\n */\r\nclass Sound\r\n{\r\n    /** Pool of instances */\r\n    private static _pool: IMediaInstance[] = [];\r\n\r\n    /**\r\n     * `true` if the buffer is loaded.\r\n     * @default false\r\n     */\r\n    public isLoaded: boolean;\r\n\r\n    /**\r\n     * `true` if the sound is currently being played.\r\n     * @default false\r\n     * @readonly\r\n     */\r\n    public isPlaying: boolean;\r\n\r\n    /**\r\n     * true to start playing immediate after load.\r\n     * @default false\r\n     * @readonly\r\n     */\r\n    public autoPlay: boolean;\r\n\r\n    /**\r\n     * `true` to disallow playing multiple layered instances at once.\r\n     * @default false\r\n     */\r\n    public singleInstance: boolean;\r\n\r\n    /**\r\n     * `true` to immediately start preloading.\r\n     * @default false\r\n     * @readonly\r\n     */\r\n    public preload: boolean;\r\n\r\n    /**\r\n     * The file source to load.\r\n     * @readonly\r\n     */\r\n    public url: string;\r\n\r\n    /**\r\n     * The constructor options.\r\n     * @readonly\r\n     */\r\n    public options: Options;\r\n\r\n    /** The audio source */\r\n    public media: IMedia;\r\n\r\n    /** The list of play calls while waiting to preload the sound. */\r\n    private _preloadQueue: (() => void)[] | null;\r\n\r\n    /** The collection of instances being played. */\r\n    private _instances: IMediaInstance[];\r\n\r\n    /** The user defined sound sprites. */\r\n    private _sprites: SoundSprites;\r\n\r\n    /** The options when auto-playing. */\r\n    private _autoPlayOptions: PlayOptions;\r\n\r\n    /** The internal volume. */\r\n    private _volume: number;\r\n\r\n    /** The internal paused state. */\r\n    private _paused: boolean;\r\n\r\n    /** The internal muted state. */\r\n    private _muted: boolean;\r\n\r\n    /** The internal volume. */\r\n    private _loop: boolean;\r\n\r\n    /** The internal playbackRate */\r\n    private _speed: number;\r\n\r\n    /**\r\n     * Create a new sound instance from source.\r\n     * @param source - Either the path or url to the source file.\r\n     *        or the object of options to use.\r\n     * @return Created sound instance.\r\n     */\r\n    public static from(source: string | string[] | Options | ArrayBuffer | HTMLAudioElement | AudioBuffer): Sound\r\n    {\r\n        let options: Options = {};\r\n\r\n        if (typeof source === 'string')\r\n        {\r\n            options.url = source as string;\r\n        }\r\n        else if (source instanceof ArrayBuffer || source instanceof AudioBuffer || source instanceof HTMLAudioElement)\r\n        {\r\n            options.source = source;\r\n        }\r\n        else if (Array.isArray(source))\r\n        {\r\n            options.url = source;\r\n        }\r\n        else\r\n        {\r\n            options = source;\r\n        }\r\n\r\n        // Default settings\r\n        options = {\r\n            autoPlay: false,\r\n            singleInstance: false,\r\n            url: null,\r\n            source: null,\r\n            preload: false,\r\n            volume: 1,\r\n            speed: 1,\r\n            complete: null,\r\n            loaded: null,\r\n            loop: false, ...options\r\n        };\r\n\r\n        Object.freeze(options);\r\n\r\n        const media: IMedia = getInstance().useLegacy\r\n            ? new HTMLAudioMedia()\r\n            : new WebAudioMedia();\r\n\r\n        return new Sound(media, options);\r\n    }\r\n\r\n    /**\r\n     * Use `Sound.from`\r\n     * @ignore\r\n     */\r\n    constructor(media: IMedia, options: Options)\r\n    {\r\n        this.media = media;\r\n        this.options = options;\r\n        this._instances = [];\r\n        this._sprites = {};\r\n\r\n        this.media.init(this);\r\n\r\n        const complete = options.complete;\r\n\r\n        this._autoPlayOptions = complete ? { complete } : null;\r\n        this.isLoaded = false;\r\n        this._preloadQueue = null;\r\n        this.isPlaying = false;\r\n        this.autoPlay = options.autoPlay;\r\n        this.singleInstance = options.singleInstance;\r\n        this.preload = options.preload || this.autoPlay;\r\n\r\n        this.url = Array.isArray(options.url)\r\n            ? this.preferUrl(options.url)\r\n            : options.url;\r\n        this.speed = options.speed;\r\n        this.volume = options.volume;\r\n        this.loop = options.loop;\r\n\r\n        if (options.sprites)\r\n        {\r\n            this.addSprites(options.sprites);\r\n        }\r\n\r\n        if (this.preload)\r\n        {\r\n            this._preload(options.loaded);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Internal help for resolving which file to use if there are multiple provide\r\n     * this is especially helpful for working with bundlers (non Assets loading).\r\n     */\r\n    private preferUrl(urls: string[]): string\r\n    {\r\n        const [file] = urls\r\n            .map((url) => ({ url, ext: path.extname(url).slice(1) }))\r\n            .filter(({ ext }) => supported[ext])\r\n            .sort((a, b) => extensions.indexOf(a.ext) - extensions.indexOf(b.ext));\r\n\r\n        if (!file)\r\n        {\r\n            throw new Error('No supported file type found');\r\n        }\r\n\r\n        return file.url;\r\n    }\r\n\r\n    /** Instance of the media context. */\r\n    public get context(): IMediaContext\r\n    {\r\n        return getInstance().context;\r\n    }\r\n\r\n    /** Stops all the instances of this sound from playing. */\r\n    public pause(): this\r\n    {\r\n        this.isPlaying = false;\r\n        this.paused = true;\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Resuming all the instances of this sound from playing */\r\n    public resume(): this\r\n    {\r\n        this.isPlaying = this._instances.length > 0;\r\n        this.paused = false;\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Stops all the instances of this sound from playing. */\r\n    public get paused(): boolean\r\n    {\r\n        return this._paused;\r\n    }\r\n    public set paused(paused: boolean)\r\n    {\r\n        this._paused = paused;\r\n        this.refreshPaused();\r\n    }\r\n\r\n    /** The playback rate. */\r\n    public get speed(): number\r\n    {\r\n        return this._speed;\r\n    }\r\n    public set speed(speed: number)\r\n    {\r\n        this._speed = speed;\r\n        this.refresh();\r\n    }\r\n\r\n    /** Set the filters. Only supported with WebAudio. */\r\n    public get filters(): Filter[]\r\n    {\r\n        return this.media.filters;\r\n    }\r\n    public set filters(filters: Filter[])\r\n    {\r\n        this.media.filters = filters;\r\n    }\r\n\r\n    /**\r\n     * Add a sound sprite, which is a saved instance of a longer sound.\r\n     * Similar to an image spritesheet.\r\n     * @param alias - The unique name of the sound sprite.\r\n     * @param data - Either completed function or play options.\r\n     */\r\n    public addSprites(alias: string, data: SoundSpriteData): SoundSprite;\r\n\r\n    /**\r\n     * Convenience method to add more than one sprite add a time.\r\n     * @param data - Map of sounds to add where the key is the alias,\r\n     *        and the data are configuration options.\r\n     * @return The map of sound sprites added.\r\n     */\r\n    public addSprites(data: SoundSpriteDataMap): SoundSprites;\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    public addSprites(source: string | SoundSpriteDataMap, data?: SoundSpriteData): any\r\n    {\r\n        if (typeof source === 'object')\r\n        {\r\n            const results: SoundSprites = {};\r\n\r\n            for (const alias in source)\r\n            {\r\n                results[alias] = this.addSprites(alias, source[alias]);\r\n            }\r\n\r\n            return results;\r\n        }\r\n\r\n        // eslint-disable-next-line no-console\r\n        console.assert(!this._sprites[source], `Alias ${source} is already taken`);\r\n        const sprite = new SoundSprite(this, data);\r\n\r\n        this._sprites[source] = sprite;\r\n\r\n        return sprite;\r\n    }\r\n\r\n    /** Destructor, safer to use `SoundLibrary.remove(alias)` to remove this sound. */\r\n    public destroy(): void\r\n    {\r\n        this._removeInstances();\r\n        this.removeSprites();\r\n        this.media.destroy();\r\n        this.media = null;\r\n        this._sprites = null;\r\n        this._instances = null;\r\n    }\r\n\r\n    /**\r\n     * Remove a sound sprite.\r\n     * @param alias - The unique name of the sound sprite, if alias is omitted, removes all sprites.\r\n     */\r\n    public removeSprites(alias?: string): Sound\r\n    {\r\n        if (!alias)\r\n        {\r\n            for (const name in this._sprites)\r\n            {\r\n                this.removeSprites(name);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            const sprite: SoundSprite = this._sprites[alias];\r\n\r\n            if (sprite !== undefined)\r\n            {\r\n                sprite.destroy();\r\n                delete this._sprites[alias];\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /** If the current sound is playable (loaded). */\r\n    public get isPlayable(): boolean\r\n    {\r\n        return this.isLoaded && this.media && this.media.isPlayable;\r\n    }\r\n\r\n    /** Stops all the instances of this sound from playing. */\r\n    public stop(): this\r\n    {\r\n        if (!this.isPlayable)\r\n        {\r\n            this.autoPlay = false;\r\n            this._autoPlayOptions = null;\r\n\r\n            return this;\r\n        }\r\n        this.isPlaying = false;\r\n\r\n        // Go in reverse order so we don't skip items\r\n        for (let i = this._instances.length - 1; i >= 0; i--)\r\n        {\r\n            this._instances[i].stop();\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Play a sound sprite, which is a saved instance of a longer sound.\r\n     * Similar to an image spritesheet.\r\n     * @method play\r\n     * @instance\r\n     * @param alias - The unique name of the sound sprite.\r\n     * @param {Function} callback - Callback when completed.\r\n     * @return The sound instance,\r\n     *        this cannot be reused after it is done playing. Returns a Promise if the sound\r\n     *        has not yet loaded.\r\n     */\r\n    public play(alias: string, callback?: CompleteCallback): IMediaInstance | Promise<IMediaInstance>;\r\n\r\n    /**\r\n     * Plays the sound.\r\n     * @method play\r\n     * @instance\r\n     * @param {Function|PlayOptions} source - Either completed function or play options.\r\n     * @param {Function} callback - Callback when completed.\r\n     * @return The sound instance,\r\n     *        this cannot be reused after it is done playing. Returns a Promise if the sound\r\n     *        has not yet loaded.\r\n     */\r\n    public play(source?: string | PlayOptions | CompleteCallback,\r\n        callback?: CompleteCallback): IMediaInstance | Promise<IMediaInstance>;\r\n\r\n    // Overloaded function\r\n    public play(source?: string | PlayOptions | CompleteCallback,\r\n        complete?: CompleteCallback): IMediaInstance | Promise<IMediaInstance>\r\n    {\r\n        let options: PlayOptions;\r\n\r\n        if (typeof source === 'string')\r\n        {\r\n            const sprite: string = source as string;\r\n\r\n            options = { sprite, loop: this.loop, complete };\r\n        }\r\n        else if (typeof source === 'function')\r\n        {\r\n            options = {};\r\n            options.complete = source as CompleteCallback;\r\n        }\r\n        else\r\n        {\r\n            options = source as PlayOptions;\r\n        }\r\n\r\n        options = {\r\n            complete: null,\r\n            loaded: null,\r\n            sprite: null,\r\n            end: null,\r\n            start: 0,\r\n            volume: 1,\r\n            speed: 1,\r\n            muted: false,\r\n            loop: false, ...(options || {})\r\n        };\r\n\r\n        // A sprite is specified, add the options\r\n        if (options.sprite)\r\n        {\r\n            const alias: string = options.sprite;\r\n\r\n            // eslint-disable-next-line no-console\r\n            console.assert(!!this._sprites[alias], `Alias ${alias} is not available`);\r\n            const sprite: SoundSprite = this._sprites[alias];\r\n\r\n            options.start = sprite.start + (options.start || 0);\r\n            options.end = sprite.end;\r\n            options.speed = sprite.speed || 1;\r\n            options.loop = sprite.loop || options.loop;\r\n            delete options.sprite;\r\n        }\r\n\r\n        // @deprecated offset option\r\n        if ((options as any).offset)\r\n        {\r\n            options.start = (options as any).offset as number;\r\n        }\r\n\r\n        // if not yet playable, ignore\r\n        // - usefull when the sound download isnt yet completed\r\n        if (!this.isLoaded)\r\n        {\r\n            // Handle the case when trying to play a sound that is not yet loaded\r\n            // We'll add it to a queue to play after initial load finishes\r\n            if (this._preloadQueue)\r\n            {\r\n                return new Promise<IMediaInstance>((resolve) =>\r\n                {\r\n                    this._preloadQueue.push(() =>\r\n                    {\r\n                        resolve(this.play(options));\r\n                    });\r\n                });\r\n            }\r\n\r\n            this._preloadQueue = [];\r\n            this.autoPlay = true;\r\n            this._autoPlayOptions = options;\r\n\r\n            return new Promise<IMediaInstance>((resolve, reject) =>\r\n            {\r\n                this._preload((err: Error, sound: Sound, media: IMediaInstance) =>\r\n                {\r\n                    this._preloadQueue.forEach((resolve) => resolve());\r\n                    this._preloadQueue = null;\r\n\r\n                    if (err)\r\n                    {\r\n                        reject(err);\r\n                    }\r\n                    else\r\n                    {\r\n                        if (options.loaded)\r\n                        {\r\n                            options.loaded(err, sound, media);\r\n                        }\r\n                        resolve(media);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n\r\n        // Stop all sounds\r\n        if (this.singleInstance || options.singleInstance)\r\n        {\r\n            this._removeInstances();\r\n        }\r\n\r\n        // clone the bufferSource\r\n        const instance = this._createInstance();\r\n\r\n        this._instances.push(instance);\r\n        this.isPlaying = true;\r\n        instance.once('end', () =>\r\n        {\r\n            if (options.complete)\r\n            {\r\n                options.complete(this);\r\n            }\r\n            this._onComplete(instance);\r\n        });\r\n        instance.once('stop', () =>\r\n        {\r\n            this._onComplete(instance);\r\n        });\r\n\r\n        instance.play(options);\r\n\r\n        return instance;\r\n    }\r\n\r\n    /** Internal only, speed, loop, volume change occured. */\r\n    public refresh(): void\r\n    {\r\n        const len = this._instances.length;\r\n\r\n        for (let i = 0; i < len; i++)\r\n        {\r\n            this._instances[i].refresh();\r\n        }\r\n    }\r\n\r\n    /** Handle changes in paused state. Internal only. */\r\n    public refreshPaused(): void\r\n    {\r\n        const len = this._instances.length;\r\n\r\n        for (let i = 0; i < len; i++)\r\n        {\r\n            this._instances[i].refreshPaused();\r\n        }\r\n    }\r\n\r\n    /** Gets and sets the volume. */\r\n    public get volume(): number\r\n    {\r\n        return this._volume;\r\n    }\r\n    public set volume(volume: number)\r\n    {\r\n        this._volume = volume;\r\n        this.refresh();\r\n    }\r\n\r\n    /** Gets and sets the muted flag. */\r\n    public get muted(): boolean\r\n    {\r\n        return this._muted;\r\n    }\r\n    public set muted(muted: boolean)\r\n    {\r\n        this._muted = muted;\r\n        this.refresh();\r\n    }\r\n\r\n    /** Gets and sets the looping. */\r\n    public get loop(): boolean\r\n    {\r\n        return this._loop;\r\n    }\r\n    public set loop(loop: boolean)\r\n    {\r\n        this._loop = loop;\r\n        this.refresh();\r\n    }\r\n\r\n    /** Starts the preloading of sound. */\r\n    private _preload(callback?: LoadedCallback): void\r\n    {\r\n        this.media.load(callback);\r\n    }\r\n\r\n    /** Gets the list of instances that are currently being played of this sound. */\r\n    public get instances(): IMediaInstance[]\r\n    {\r\n        return this._instances;\r\n    }\r\n\r\n    /** Get the map of sprites. */\r\n    public get sprites(): SoundSprites\r\n    {\r\n        return this._sprites;\r\n    }\r\n\r\n    /** Get the duration of the audio in seconds. */\r\n    public get duration(): number\r\n    {\r\n        return this.media.duration;\r\n    }\r\n\r\n    /** Auto play the first instance. */\r\n    public autoPlayStart(): IMediaInstance\r\n    {\r\n        let instance: IMediaInstance;\r\n\r\n        if (this.autoPlay)\r\n        {\r\n            instance = this.play(this._autoPlayOptions) as IMediaInstance;\r\n        }\r\n\r\n        return instance;\r\n    }\r\n\r\n    /** Removes all instances. */\r\n    private _removeInstances(): void\r\n    {\r\n        // destroying also stops\r\n        for (let i = this._instances.length - 1; i >= 0; i--)\r\n        {\r\n            this._poolInstance(this._instances[i]);\r\n        }\r\n        this._instances.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Sound instance completed.\r\n     * @param instance\r\n     */\r\n    private _onComplete(instance: IMediaInstance): void\r\n    {\r\n        if (this._instances)\r\n        {\r\n            const index = this._instances.indexOf(instance);\r\n\r\n            if (index > -1)\r\n            {\r\n                this._instances.splice(index, 1);\r\n            }\r\n            this.isPlaying = this._instances.length > 0;\r\n        }\r\n        this._poolInstance(instance);\r\n    }\r\n\r\n    /** Create a new instance. */\r\n    private _createInstance(): IMediaInstance\r\n    {\r\n        if (Sound._pool.length > 0)\r\n        {\r\n            const instance: IMediaInstance = Sound._pool.pop();\r\n\r\n            instance.init(this.media);\r\n\r\n            return instance;\r\n        }\r\n\r\n        return this.media.create();\r\n    }\r\n\r\n    /**\r\n     * Destroy/recycling the instance object.\r\n     * @param instance - Instance to recycle\r\n     */\r\n    private _poolInstance(instance: IMediaInstance): void\r\n    {\r\n        instance.destroy();\r\n        // Add it if it isn't already added\r\n        if (Sound._pool.indexOf(instance) < 0)\r\n        {\r\n            Sound._pool.push(instance);\r\n        }\r\n    }\r\n}\r\n\r\nexport { Sound };\r\nexport type {\r\n    CompleteCallback,\r\n    LoadedCallback,\r\n    Options,\r\n    PlayOptions,\r\n    SoundSpriteDataMap\r\n};\r\n","import { EventEmitter } from 'pixi.js';\r\nimport { Filterable } from '../Filterable';\r\nimport { IMediaContext } from '../interfaces';\r\n\r\n/**\r\n * Main class to handle WebAudio API. There's a simple chain\r\n * of AudioNode elements: analyser > compressor > context.destination.\r\n * any filters that are added are inserted between the analyser and compressor nodes\r\n * @memberof webaudio\r\n */\r\nclass WebAudioContext extends Filterable implements IMediaContext\r\n{\r\n    /**\r\n     * Context Compressor node\r\n     * @readonly\r\n     */\r\n    public compressor: DynamicsCompressorNode;\r\n\r\n    /**\r\n     * Context Analyser node\r\n     * @readonly\r\n     */\r\n    public analyser: AnalyserNode;\r\n\r\n    /**\r\n     * Global speed of all sounds\r\n     * @readonly\r\n     */\r\n    public speed: number;\r\n\r\n    /**\r\n     * Sets the muted state.\r\n     * @default false\r\n     */\r\n    public muted: boolean;\r\n\r\n    /**\r\n     * Sets the volume from 0 to 1.\r\n     * @default 1\r\n     */\r\n    public volume: number;\r\n\r\n    /**\r\n     * Handle global events\r\n     * @type {PIXI.EventEmitter}\r\n     */\r\n    public events: EventEmitter;\r\n\r\n    /** The instance of the AudioContext for WebAudio API. */\r\n    private _ctx: AudioContext;\r\n\r\n    /** The instance of the OfflineAudioContext for fast decoding audio. */\r\n    private _offlineCtx: OfflineAudioContext;\r\n\r\n    /** Current paused status */\r\n    private _paused: boolean;\r\n\r\n    /**\r\n     * Indicated whether audio on iOS has been unlocked, which requires a touchend/mousedown event that plays an\r\n     * empty sound.\r\n     */\r\n    private _locked: boolean;\r\n\r\n    /** The paused state when blurring the current window */\r\n    private _pausedOnBlur: boolean;\r\n\r\n    /** Set to false ignore suspending when window is blurred */\r\n    public autoPause = true;\r\n\r\n    constructor()\r\n    {\r\n        const win: any = window as any;\r\n        const ctx = new WebAudioContext.AudioContext();\r\n        const compressor: DynamicsCompressorNode = ctx.createDynamicsCompressor();\r\n        const analyser: AnalyserNode = ctx.createAnalyser();\r\n\r\n        // setup the end of the node chain\r\n        analyser.connect(compressor);\r\n        compressor.connect(ctx.destination);\r\n\r\n        super(analyser, compressor);\r\n\r\n        this._ctx = ctx;\r\n        // ios11 safari's webkitOfflineAudioContext allows only 44100 Hz sample rate\r\n        //\r\n        // For the sample rate value passed to OfflineAudioContext constructor,\r\n        // all browsers are required to support a range of 8000 to 96000.\r\n        // Reference:\r\n        // https://www.w3.org/TR/webaudio/#dom-offlineaudiocontext-offlineaudiocontext-numberofchannels-length-samplerate\r\n        this._offlineCtx = new WebAudioContext.OfflineAudioContext(1, 2,\r\n            (win.OfflineAudioContext) ? Math.max(8000, Math.min(96000, ctx.sampleRate)) : 44100);\r\n\r\n        this.compressor = compressor;\r\n        this.analyser = analyser;\r\n        this.events = new EventEmitter();\r\n\r\n        // Set the defaults\r\n        this.volume = 1;\r\n        this.speed = 1;\r\n        this.muted = false;\r\n        this.paused = false;\r\n\r\n        this._locked = ctx.state === 'suspended' && ('ontouchstart' in globalThis || 'onclick' in globalThis);\r\n\r\n        // Listen for document level clicks to unlock WebAudio. See the _unlock method.\r\n        if (this._locked)\r\n        {\r\n            this._unlock(); // When played inside of a touch event, this will enable audio on iOS immediately.\r\n            this._unlock = this._unlock.bind(this);\r\n            document.addEventListener('mousedown', this._unlock, true);\r\n            document.addEventListener('touchstart', this._unlock, true);\r\n            document.addEventListener('touchend', this._unlock, true);\r\n        }\r\n\r\n        this.onFocus = this.onFocus.bind(this);\r\n        this.onBlur = this.onBlur.bind(this);\r\n        globalThis.addEventListener('focus', this.onFocus);\r\n        globalThis.addEventListener('blur', this.onBlur);\r\n    }\r\n\r\n    /** Handle mobile WebAudio context resume */\r\n    private onFocus(): void\r\n    {\r\n        if (!this.autoPause)\r\n        {\r\n            return;\r\n        }\r\n        // Safari uses the non-standard \"interrupted\" state in some cases\r\n        // such as when the app loses focus because the screen is locked\r\n        // or when the user switches to another app.\r\n        const state = this._ctx.state as 'suspended' | 'interrupted';\r\n\r\n        if (state === 'suspended' || state === 'interrupted' || !this._locked)\r\n        {\r\n            this.paused = this._pausedOnBlur;\r\n            this.refreshPaused();\r\n        }\r\n    }\r\n\r\n    /** Handle mobile WebAudio context suspend */\r\n    private onBlur(): void\r\n    {\r\n        if (!this.autoPause)\r\n        {\r\n            return;\r\n        }\r\n        if (!this._locked)\r\n        {\r\n            this._pausedOnBlur = this._paused;\r\n            this.paused = true;\r\n            this.refreshPaused();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Try to unlock audio on iOS. This is triggered from either WebAudio plugin setup (which will work if inside of\r\n     * a `mousedown` or `touchend` event stack), or the first document touchend/mousedown event. If it fails (touchend\r\n     * will fail if the user presses for too long, indicating a scroll event instead of a click event.\r\n     *\r\n     * Note that earlier versions of iOS supported `touchstart` for this, but iOS9 removed this functionality. Adding\r\n     * a `touchstart` event to support older platforms may preclude a `mousedown` even from getting fired on iOS9, so we\r\n     * stick with `mousedown` and `touchend`.\r\n     */\r\n    private _unlock(): void\r\n    {\r\n        if (!this._locked)\r\n        {\r\n            return;\r\n        }\r\n        this.playEmptySound();\r\n        if (this._ctx.state === 'running')\r\n        {\r\n            document.removeEventListener('mousedown', this._unlock, true);\r\n            document.removeEventListener('touchend', this._unlock, true);\r\n            document.removeEventListener('touchstart', this._unlock, true);\r\n            this._locked = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Plays an empty sound in the web audio context.  This is used to enable web audio on iOS devices, as they\r\n     * require the first sound to be played inside of a user initiated event (touch/click).\r\n     */\r\n    public playEmptySound(): void\r\n    {\r\n        const source = this._ctx.createBufferSource();\r\n\r\n        source.buffer = this._ctx.createBuffer(1, 1, 22050);\r\n        source.connect(this._ctx.destination);\r\n        source.start(0, 0, 0);\r\n        if (source.context.state === 'suspended')\r\n        {\r\n            (source.context as AudioContext).resume();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get AudioContext class, if not supported returns `null`\r\n     * @type {AudioContext}\r\n     * @readonly\r\n     */\r\n    public static get AudioContext(): typeof AudioContext\r\n    {\r\n        const win: any = window as any;\r\n\r\n        return (\r\n            win.AudioContext\r\n            || win.webkitAudioContext\r\n            || null\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get OfflineAudioContext class, if not supported returns `null`\r\n     * @type {OfflineAudioContext}\r\n     * @readonly\r\n     */\r\n    public static get OfflineAudioContext(): typeof OfflineAudioContext\r\n    {\r\n        const win: any = window as any;\r\n\r\n        return (\r\n            win.OfflineAudioContext\r\n            || win.webkitOfflineAudioContext\r\n            || null\r\n        );\r\n    }\r\n\r\n    /** Destroy this context. */\r\n    public destroy(): void\r\n    {\r\n        super.destroy();\r\n\r\n        const ctx: any = this._ctx as any;\r\n        // check if browser supports AudioContext.close()\r\n\r\n        if (typeof ctx.close !== 'undefined')\r\n        {\r\n            ctx.close();\r\n        }\r\n        globalThis.removeEventListener('focus', this.onFocus);\r\n        globalThis.removeEventListener('blur', this.onBlur);\r\n        this.events.removeAllListeners();\r\n        this.analyser.disconnect();\r\n        this.compressor.disconnect();\r\n        this.analyser = null;\r\n        this.compressor = null;\r\n        this.events = null;\r\n        this._offlineCtx = null;\r\n        this._ctx = null;\r\n    }\r\n\r\n    /**\r\n     * The WebAudio API AudioContext object.\r\n     * @readonly\r\n     * @type {AudioContext}\r\n     */\r\n    public get audioContext(): AudioContext\r\n    {\r\n        return this._ctx;\r\n    }\r\n\r\n    /**\r\n     * The WebAudio API OfflineAudioContext object.\r\n     * @readonly\r\n     * @type {OfflineAudioContext}\r\n     */\r\n    public get offlineContext(): OfflineAudioContext\r\n    {\r\n        return this._offlineCtx;\r\n    }\r\n\r\n    /**\r\n     * Pauses all sounds, even though we handle this at the instance\r\n     * level, we'll also pause the audioContext so that the\r\n     * time used to compute progress isn't messed up.\r\n     * @default false\r\n     */\r\n    public set paused(paused: boolean)\r\n    {\r\n        if (paused && this._ctx.state === 'running')\r\n        {\r\n            this._ctx.suspend();\r\n        }\r\n        else if (!paused && this._ctx.state === 'suspended')\r\n        {\r\n            this._ctx.resume();\r\n        }\r\n        this._paused = paused;\r\n    }\r\n    public get paused(): boolean\r\n    {\r\n        return this._paused;\r\n    }\r\n\r\n    /** Emit event when muted, volume or speed changes */\r\n    public refresh(): void\r\n    {\r\n        this.events.emit('refresh');\r\n    }\r\n\r\n    /** Emit event when muted, volume or speed changes */\r\n    public refreshPaused(): void\r\n    {\r\n        this.events.emit('refreshPaused');\r\n    }\r\n\r\n    /**\r\n     * Toggles the muted state.\r\n     * @return The current muted state.\r\n     */\r\n    public toggleMute(): boolean\r\n    {\r\n        this.muted = !this.muted;\r\n        this.refresh();\r\n\r\n        return this.muted;\r\n    }\r\n\r\n    /**\r\n     * Toggles the paused state.\r\n     * @return The current muted state.\r\n     */\r\n    public togglePause(): boolean\r\n    {\r\n        this.paused = !this.paused;\r\n        this.refreshPaused();\r\n\r\n        return this._paused;\r\n    }\r\n\r\n    /**\r\n     * Decode the audio data\r\n     * @param arrayBuffer - Buffer from loader\r\n     * @param callback - When completed, error and audioBuffer are parameters.\r\n     */\r\n    public decode(arrayBuffer: ArrayBuffer, callback: (err?: Error, buffer?: AudioBuffer) => void): void\r\n    {\r\n        const handleError = (err: Error) =>\r\n        {\r\n            callback(new Error(err?.message || 'Unable to decode file'));\r\n        };\r\n        const result = this._offlineCtx.decodeAudioData(\r\n            arrayBuffer, (buffer: AudioBuffer) =>\r\n            {\r\n                callback(null, buffer);\r\n            },\r\n            handleError,\r\n        );\r\n        // Reference: https://developer.mozilla.org/en-US/docs/Web/API/BaseAudioContext/decodeAudioData\r\n        // decodeAudioData return value: Void, or a Promise object that fulfills with the decodedData.\r\n\r\n        if (result)\r\n        {\r\n            result.catch(handleError);\r\n        }\r\n    }\r\n}\r\n\r\nexport { WebAudioContext };\r\n","import { Filter } from './filters/Filter';\r\nimport { HTMLAudioContext } from './htmlaudio/HTMLAudioContext';\r\nimport { IMediaContext } from './interfaces/IMediaContext';\r\nimport { IMediaInstance } from './interfaces/IMediaInstance';\r\nimport { CompleteCallback, Options, PlayOptions, Sound } from './Sound';\r\nimport { WebAudioContext } from './webaudio/WebAudioContext';\r\n\r\ntype SoundSourceMap = Record<string, Options | string | ArrayBuffer | AudioBuffer | HTMLAudioElement>;\r\ntype SoundMap = Record<string, Sound>;\r\n\r\n/**\r\n * Manages the playback of sounds. This is the main class for PixiJS Sound. If you're\r\n * using the browser-based bundled this is `PIXI.sound`. Otherwise, you can do this:\r\n * @example\r\n * import { sound } from '@pixi/sound';\r\n *\r\n * // sound is an instance of SoundLibrary\r\n * sound.add('my-sound', 'path/to/file.mp3');\r\n * sound.play('my-sound');\r\n */\r\nclass SoundLibrary\r\n{\r\n    /**\r\n     * For legacy approach for Audio. Instead of using WebAudio API\r\n     * for playback of sounds, it will use HTML5 `<audio>` element.\r\n     */\r\n    private _useLegacy: boolean;\r\n\r\n    /** The global context to use. */\r\n    private _context: IMediaContext;\r\n\r\n    /** The WebAudio specific context */\r\n    private _webAudioContext: WebAudioContext;\r\n\r\n    /** The HTML Audio (legacy) context. */\r\n    private _htmlAudioContext: HTMLAudioContext;\r\n\r\n    /** The map of all sounds by alias. */\r\n    private _sounds: SoundMap;\r\n\r\n    constructor()\r\n    {\r\n        this.init();\r\n    }\r\n\r\n    /**\r\n     * Re-initialize the sound library, this will\r\n     * recreate the AudioContext. If there's a hardware-failure\r\n     * call `close` and then `init`.\r\n     * @return Sound instance\r\n     */\r\n    public init(): this\r\n    {\r\n        if (this.supported)\r\n        {\r\n            this._webAudioContext = new WebAudioContext();\r\n        }\r\n        this._htmlAudioContext = new HTMLAudioContext();\r\n        this._sounds = {};\r\n        this.useLegacy = !this.supported;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * The global context to use.\r\n     * @readonly\r\n     */\r\n    public get context(): IMediaContext\r\n    {\r\n        return this._context;\r\n    }\r\n\r\n    /**\r\n     * Apply filters to all sounds. Can be useful\r\n     * for setting global planning or global effects.\r\n     * **Only supported with WebAudio.**\r\n     * @example\r\n     * import { sound, filters } from '@pixi/sound';\r\n     * // Adds a filter to pan all output left\r\n     * sound.filtersAll = [\r\n     *     new filters.StereoFilter(-1)\r\n     * ];\r\n     */\r\n    public get filtersAll(): Filter[]\r\n    {\r\n        if (!this.useLegacy)\r\n        {\r\n            return this._context.filters;\r\n        }\r\n\r\n        return [];\r\n    }\r\n    public set filtersAll(filtersAll: Filter[])\r\n    {\r\n        if (!this.useLegacy)\r\n        {\r\n            this._context.filters = filtersAll;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * `true` if WebAudio is supported on the current browser.\r\n     */\r\n    public get supported(): boolean\r\n    {\r\n        return WebAudioContext.AudioContext !== null;\r\n    }\r\n\r\n    /**\r\n     * Register an existing sound with the library cache.\r\n     * @method add\r\n     * @instance\r\n     * @param {string} alias - The sound alias reference.\r\n     * @param {Sound} sound - Sound reference to use.\r\n     * @return {Sound} Instance of the Sound object.\r\n     */\r\n\r\n    /**\r\n     * Adds a new sound by alias.\r\n     * @param alias - The sound alias reference.\r\n     * @param {ArrayBuffer|AudioBuffer|String|Options|HTMLAudioElement} options - Either the path or url to the source file.\r\n     *        or the object of options to use.\r\n     * @return Instance of the Sound object.\r\n     */\r\n    public add(alias: string, options: Options | string | ArrayBuffer | AudioBuffer | HTMLAudioElement | Sound): Sound;\r\n\r\n    /**\r\n     * Adds multiple sounds at once.\r\n     * @param map - Map of sounds to add, the key is the alias, the value is the\r\n     *        `string`, `ArrayBuffer`, `AudioBuffer`, `HTMLAudioElement` or the list of options\r\n     *        (see {@link Options} for full options).\r\n     * @param globalOptions - The default options for all sounds.\r\n     *        if a property is defined, it will use the local property instead.\r\n     * @return Instance to the Sound object.\r\n     */\r\n    public add(map: SoundSourceMap, globalOptions?: Options): SoundMap;\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    public add(source: string | SoundSourceMap,\r\n        sourceOptions?: Options | string | ArrayBuffer | AudioBuffer | HTMLAudioElement | Sound): any\r\n    {\r\n        if (typeof source === 'object')\r\n        {\r\n            const results: SoundMap = {};\r\n\r\n            for (const alias in source)\r\n            {\r\n                const options: Options = this._getOptions(\r\n                    source[alias],\r\n                    sourceOptions as Options,\r\n                );\r\n\r\n                results[alias] = this.add(alias, options);\r\n            }\r\n\r\n            return results;\r\n        }\r\n\r\n        // eslint-disable-next-line no-console\r\n        console.assert(!this._sounds[source], `Sound with alias ${source} already exists.`);\r\n\r\n        if (sourceOptions instanceof Sound)\r\n        {\r\n            this._sounds[source] = sourceOptions;\r\n\r\n            return sourceOptions;\r\n        }\r\n\r\n        const options: Options = this._getOptions(sourceOptions);\r\n        const sound: Sound = Sound.from(options);\r\n\r\n        this._sounds[source] = sound;\r\n\r\n        return sound;\r\n    }\r\n\r\n    /**\r\n     * Internal methods for getting the options object\r\n     * @private\r\n     * @param source - The source options\r\n     * @param overrides - Override default options\r\n     * @return The construction options\r\n     */\r\n    private _getOptions(source: string | ArrayBuffer | AudioBuffer | HTMLAudioElement | Options,\r\n        overrides?: Options): Options\r\n    {\r\n        let options: Options;\r\n\r\n        if (typeof source === 'string')\r\n        {\r\n            options = { url: source };\r\n        }\r\n        else if (Array.isArray(source))\r\n        {\r\n            options = { url: source };\r\n        }\r\n        else if (source instanceof ArrayBuffer || source instanceof AudioBuffer || source instanceof HTMLAudioElement)\r\n        {\r\n            options = { source };\r\n        }\r\n        else\r\n        {\r\n            options = source as Options;\r\n        }\r\n        options = { ...options, ...(overrides || {}) };\r\n\r\n        return options;\r\n    }\r\n\r\n    /**\r\n     * Do not use WebAudio, force the use of legacy. This **must** be called before loading any files.\r\n     */\r\n    public get useLegacy(): boolean\r\n    {\r\n        return this._useLegacy;\r\n    }\r\n    public set useLegacy(legacy: boolean)\r\n    {\r\n        this._useLegacy = legacy;\r\n\r\n        // Set the context to use\r\n        this._context = (!legacy && this.supported)\r\n            ? this._webAudioContext\r\n            : this._htmlAudioContext;\r\n    }\r\n\r\n    /**\r\n     * This disables auto-pause all playback when the window blurs (WebAudio only).\r\n     * This is helpful to keep from playing sounds when the user switches tabs.\r\n     * However, if you're running content within an iframe, this may be undesirable\r\n     * and you should disable (set to `true`) this behavior.\r\n     * @default false\r\n     */\r\n    public get disableAutoPause(): boolean\r\n    {\r\n        return !this._webAudioContext.autoPause;\r\n    }\r\n    public set disableAutoPause(autoPause: boolean)\r\n    {\r\n        this._webAudioContext.autoPause = !autoPause;\r\n    }\r\n\r\n    /**\r\n     * Removes a sound by alias.\r\n     * @param alias - The sound alias reference.\r\n     * @return Instance for chaining.\r\n     */\r\n    public remove(alias: string): this\r\n    {\r\n        this.exists(alias, true);\r\n        this._sounds[alias].destroy();\r\n        delete this._sounds[alias];\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set the global volume for all sounds. To set per-sound volume see {@link SoundLibrary#volume}.\r\n     */\r\n    public get volumeAll(): number\r\n    {\r\n        return this._context.volume;\r\n    }\r\n    public set volumeAll(volume: number)\r\n    {\r\n        this._context.volume = volume;\r\n        this._context.refresh();\r\n    }\r\n\r\n    /**\r\n     * Set the global speed for all sounds. To set per-sound speed see {@link SoundLibrary#speed}.\r\n     */\r\n    public get speedAll(): number\r\n    {\r\n        return this._context.speed;\r\n    }\r\n    public set speedAll(speed: number)\r\n    {\r\n        this._context.speed = speed;\r\n        this._context.refresh();\r\n    }\r\n\r\n    /**\r\n     * Toggle paused property for all sounds.\r\n     * @return `true` if all sounds are paused.\r\n     */\r\n    public togglePauseAll(): boolean\r\n    {\r\n        return this._context.togglePause();\r\n    }\r\n\r\n    /**\r\n     * Pauses any playing sounds.\r\n     * @return Instance for chaining.\r\n     */\r\n    public pauseAll(): this\r\n    {\r\n        this._context.paused = true;\r\n        this._context.refreshPaused();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Resumes any sounds.\r\n     * @return Instance for chaining.\r\n     */\r\n    public resumeAll(): this\r\n    {\r\n        this._context.paused = false;\r\n        this._context.refreshPaused();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Toggle muted property for all sounds.\r\n     * @return `true` if all sounds are muted.\r\n     */\r\n    public toggleMuteAll(): boolean\r\n    {\r\n        return this._context.toggleMute();\r\n    }\r\n\r\n    /**\r\n     * Mutes all playing sounds.\r\n     * @return Instance for chaining.\r\n     */\r\n    public muteAll(): this\r\n    {\r\n        this._context.muted = true;\r\n        this._context.refresh();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Unmutes all playing sounds.\r\n     * @return Instance for chaining.\r\n     */\r\n    public unmuteAll(): this\r\n    {\r\n        this._context.muted = false;\r\n        this._context.refresh();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Stops and removes all sounds. They cannot be used after this.\r\n     * @return Instance for chaining.\r\n     */\r\n    public removeAll(): this\r\n    {\r\n        for (const alias in this._sounds)\r\n        {\r\n            this._sounds[alias].destroy();\r\n            delete this._sounds[alias];\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Stops all sounds.\r\n     * @return Instance for chaining.\r\n     */\r\n    public stopAll(): this\r\n    {\r\n        for (const alias in this._sounds)\r\n        {\r\n            this._sounds[alias].stop();\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Checks if a sound by alias exists.\r\n     * @param alias - Check for alias.\r\n     * @param assert - Whether enable console.assert.\r\n     * @return true if the sound exists.\r\n     */\r\n    public exists(alias: string, assert = false): boolean\r\n    {\r\n        const exists = !!this._sounds[alias];\r\n\r\n        if (assert)\r\n        {\r\n            // eslint-disable-next-line no-console\r\n            console.assert(exists, `No sound matching alias '${alias}'.`);\r\n        }\r\n\r\n        return exists;\r\n    }\r\n\r\n    /**\r\n     * Convenience function to check to see if any sound is playing.\r\n     * @returns `true` if any sound is currently playing.\r\n     */\r\n    public isPlaying(): boolean\r\n    {\r\n        for (const alias in this._sounds)\r\n        {\r\n            if (this._sounds[alias].isPlaying)\r\n            {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Find a sound by alias.\r\n     * @param alias - The sound alias reference.\r\n     * @return Sound object.\r\n     */\r\n    public find(alias: string): Sound\r\n    {\r\n        this.exists(alias, true);\r\n\r\n        return this._sounds[alias];\r\n    }\r\n\r\n    /**\r\n     * Plays a sound.\r\n     * @method play\r\n     * @instance\r\n     * @param {string} alias - The sound alias reference.\r\n     * @param {string} sprite - The alias of the sprite to play.\r\n     * @return {IMediaInstance|null} The sound instance, this cannot be reused\r\n     *         after it is done playing. Returns `null` if the sound has not yet loaded.\r\n     */\r\n\r\n    /**\r\n     * Plays a sound.\r\n     * @param alias - The sound alias reference.\r\n     * @param {PlayOptions|Function} options - The options or callback when done.\r\n     * @return The sound instance,\r\n     *        this cannot be reused after it is done playing. Returns a Promise if the sound\r\n     *        has not yet loaded.\r\n     */\r\n    public play(\r\n        alias: string,\r\n        options?: PlayOptions | CompleteCallback | string): IMediaInstance | Promise<IMediaInstance>\r\n    {\r\n        return this.find(alias).play(options);\r\n    }\r\n\r\n    /**\r\n     * Stops a sound.\r\n     * @param alias - The sound alias reference.\r\n     * @return Sound object.\r\n     */\r\n    public stop(alias: string): Sound\r\n    {\r\n        return this.find(alias).stop();\r\n    }\r\n\r\n    /**\r\n     * Pauses a sound.\r\n     * @param alias - The sound alias reference.\r\n     * @return Sound object.\r\n     */\r\n    public pause(alias: string): Sound\r\n    {\r\n        return this.find(alias).pause();\r\n    }\r\n\r\n    /**\r\n     * Resumes a sound.\r\n     * @param alias - The sound alias reference.\r\n     * @return Instance for chaining.\r\n     */\r\n    public resume(alias: string): Sound\r\n    {\r\n        return this.find(alias).resume();\r\n    }\r\n\r\n    /**\r\n     * Get or set the volume for a sound.\r\n     * @param alias - The sound alias reference.\r\n     * @param volume - Optional current volume to set.\r\n     * @return The current volume.\r\n     */\r\n    public volume(alias: string, volume?: number): number\r\n    {\r\n        const sound = this.find(alias);\r\n\r\n        if (volume !== undefined)\r\n        {\r\n            sound.volume = volume;\r\n        }\r\n\r\n        return sound.volume;\r\n    }\r\n\r\n    /**\r\n     * Get or set the speed for a sound.\r\n     * @param alias - The sound alias reference.\r\n     * @param speed - Optional current speed to set.\r\n     * @return The current speed.\r\n     */\r\n    public speed(alias: string, speed?: number): number\r\n    {\r\n        const sound = this.find(alias);\r\n\r\n        if (speed !== undefined)\r\n        {\r\n            sound.speed = speed;\r\n        }\r\n\r\n        return sound.speed;\r\n    }\r\n\r\n    /**\r\n     * Get the length of a sound in seconds.\r\n     * @param alias - The sound alias reference.\r\n     * @return The current duration in seconds.\r\n     */\r\n    public duration(alias: string): number\r\n    {\r\n        return this.find(alias).duration;\r\n    }\r\n\r\n    /**\r\n     * Closes the sound library. This will release/destroy\r\n     * the AudioContext(s). Can be used safely if you want to\r\n     * initialize the sound library later. Use `init` method.\r\n     */\r\n    public close(): this\r\n    {\r\n        this.removeAll();\r\n        this._sounds = null;\r\n        if (this._webAudioContext)\r\n        {\r\n            this._webAudioContext.destroy();\r\n            this._webAudioContext = null;\r\n        }\r\n        if (this._htmlAudioContext)\r\n        {\r\n            this._htmlAudioContext.destroy();\r\n            this._htmlAudioContext = null;\r\n        }\r\n        this._context = null;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nexport { SoundLibrary };\r\nexport type { SoundMap, SoundSourceMap };\r\n","import { getInstance } from '../instance';\r\n\r\n/**\r\n * Increment the alias for play once\r\n * @static\r\n * @default 0\r\n */\r\nlet PLAY_ID = 0;\r\n\r\n/**\r\n * Create a new \"Audio\" stream based on given audio path and project uri; returns the audio object.\r\n * @memberof utils\r\n * @param url - Full path of the file to play.\r\n * @param {Function} callback - Callback when complete.\r\n * @return New audio element alias.\r\n */\r\nfunction playOnce(url: string, callback?: (err?: Error) => void): string\r\n{\r\n    const alias = `alias${PLAY_ID++}`;\r\n\r\n    getInstance().add(alias, {\r\n        url,\r\n        preload: true,\r\n        autoPlay: true,\r\n        loaded: (err: Error) =>\r\n        {\r\n            if (err)\r\n            {\r\n                console.error(err);\r\n                getInstance().remove(alias);\r\n                if (callback)\r\n                {\r\n                    callback(err);\r\n                }\r\n            }\r\n        },\r\n        complete: () =>\r\n        {\r\n            getInstance().remove(alias);\r\n            if (callback)\r\n            {\r\n                callback(null);\r\n            }\r\n        },\r\n    });\r\n\r\n    return alias;\r\n}\r\n\r\nexport { PLAY_ID, playOnce };\r\n","import { CanvasSource, ICanvas, TextureSource } from 'pixi.js';\r\nimport { Sound } from '../Sound';\r\nimport { WebAudioMedia } from '../webaudio/WebAudioMedia';\r\n\r\ninterface RenderOptions\r\n{\r\n    /**\r\n     * Width of the render.\r\n     * @default 512\r\n     */\r\n    width?: number;\r\n    /**\r\n     * Height of the render.\r\n     * @default 128\r\n     */\r\n    height?: number;\r\n    /**\r\n     * Fill style for waveform.\r\n     * @default 'black'\r\n     */\r\n    fill?: string | CanvasPattern | CanvasGradient;\r\n}\r\n\r\n/**\r\n * Render image as Texture. **Only supported with WebAudio**\r\n * @memberof utils\r\n * @param sound - Instance of sound to render\r\n * @param options - Custom rendering options\r\n * @return Result texture\r\n */\r\nfunction render(sound: Sound, options?: RenderOptions): TextureSource\r\n{\r\n    const canvas: HTMLCanvasElement = document.createElement('canvas');\r\n\r\n    options = {\r\n        width: 512,\r\n        height: 128,\r\n        fill: 'black', ...(options || {})\r\n    };\r\n\r\n    canvas.width = options.width;\r\n    canvas.height = options.height;\r\n\r\n    const textureSource = new CanvasSource({\r\n        resource: canvas as ICanvas,\r\n    });\r\n\r\n    if (!(sound.media instanceof WebAudioMedia))\r\n    {\r\n        return textureSource;\r\n    }\r\n\r\n    const media: WebAudioMedia = sound.media as WebAudioMedia;\r\n\r\n    // eslint-disable-next-line no-console\r\n    console.assert(!!media.buffer, 'No buffer found, load first');\r\n\r\n    const context: CanvasRenderingContext2D = canvas.getContext('2d');\r\n\r\n    context.fillStyle = options.fill;\r\n    const data: Float32Array = media.buffer.getChannelData(0);\r\n    const step: number = Math.ceil(data.length / options.width);\r\n    const amp: number = options.height / 2;\r\n\r\n    for (let i = 0; i < options.width; i++)\r\n    {\r\n        let min = 1.0;\r\n        let max = -1.0;\r\n\r\n        for (let j = 0; j < step; j++)\r\n        {\r\n            const datum: number = data[(i * step) + j];\r\n\r\n            if (datum < min)\r\n            {\r\n                min = datum;\r\n            }\r\n            if (datum > max)\r\n            {\r\n                max = datum;\r\n            }\r\n        }\r\n        context.fillRect(i, (1 + min) * amp, 1, Math.max(1, (max - min) * amp));\r\n    }\r\n\r\n    return textureSource;\r\n}\r\n\r\nexport { render };\r\nexport type { RenderOptions };\r\n\r\n","import { Sound } from '../Sound';\r\nimport { WebAudioContext } from '../webaudio/WebAudioContext';\r\nimport { WebAudioMedia } from '../webaudio/WebAudioMedia';\r\n\r\n/**\r\n * Create a new sound for a sine wave-based tone.  **Only supported with WebAudio**\r\n * @memberof utils\r\n * @param hertz - Frequency of sound.\r\n * @param seconds - Duration of sound in seconds.\r\n * @return New sound.\r\n */\r\nfunction sineTone(hertz = 200, seconds = 1): Sound\r\n{\r\n    const sound = Sound.from({\r\n        singleInstance: true,\r\n    });\r\n\r\n    if (!(sound.media instanceof WebAudioMedia))\r\n    {\r\n        return sound;\r\n    }\r\n\r\n    const media = sound.media as WebAudioMedia;\r\n    const context = sound.context as WebAudioContext;\r\n\r\n    // set default value\r\n    const nChannels = 1;\r\n    const sampleRate = 48000;\r\n    const amplitude = 2;\r\n\r\n    // create the buffer\r\n    const buffer = context.audioContext.createBuffer(\r\n        nChannels,\r\n        seconds * sampleRate,\r\n        sampleRate,\r\n    );\r\n    const fArray = buffer.getChannelData(0);\r\n\r\n    // fill the buffer\r\n    for (let i = 0; i < fArray.length; i++)\r\n    {\r\n        const time = i / buffer.sampleRate;\r\n        const angle = hertz * time * 2 * Math.PI;\r\n\r\n        fArray[i] = Math.sin(angle) * amplitude;\r\n    }\r\n\r\n    // set the buffer\r\n    media.buffer = buffer;\r\n    sound.isLoaded = true;\r\n\r\n    return sound;\r\n}\r\n\r\nexport { sineTone };\r\n","import { AssetExtension, extensions, ExtensionType, LoaderParser, LoaderParserPriority, path, ResolvedAsset } from 'pixi.js';\r\nimport { getInstance } from './instance';\r\nimport { Options, Sound } from './Sound';\r\nimport { extensions as exts, mimes, supported } from './utils/supported';\r\n\r\n/** Get the alias for the sound */\r\nconst getAlias = (asset: ResolvedAsset) =>\r\n{\r\n    const src = asset.src;\r\n    let alias = asset?.alias?.[0];\r\n\r\n    if (!alias || asset.src === alias)\r\n    {\r\n        alias = path.basename(src, path.extname(src));\r\n    }\r\n\r\n    return alias;\r\n};\r\n\r\n/**\r\n * Simple loader plugin for loading text data.\r\n */\r\nconst soundAsset = {\r\n    extension: ExtensionType.Asset,\r\n    detection: {\r\n        test: async () => true,\r\n        add: async (formats) => [...formats, ...exts.filter((ext) => supported[ext])],\r\n        remove: async (formats) => formats.filter((ext) => formats.includes(ext)),\r\n    },\r\n    loader: {\r\n        name: 'sound',\r\n        extension: {\r\n            type: [ExtensionType.LoadParser],\r\n            priority: LoaderParserPriority.High,\r\n        },\r\n\r\n        /** Should we attempt to load this file? */\r\n        test(url: string): boolean\r\n        {\r\n            const ext = path.extname(url).slice(1);\r\n\r\n            return !!supported[ext] || mimes.some((mime) => url.startsWith(`data:${mime}`));\r\n        },\r\n\r\n        /** Load the sound file, this is mostly handled by Sound.from() */\r\n        async load(url: string, asset: ResolvedAsset<Omit<Options, 'url' | 'preload'>>): Promise<Sound>\r\n        {\r\n            // We'll use the internal Sound.from to load the asset\r\n            const sound = await new Promise<Sound>((resolve, reject) => Sound.from({\r\n                ...asset.data,\r\n                url,\r\n                preload: true,\r\n                loaded(err, sound)\r\n                {\r\n                    if (err)\r\n                    {\r\n                        reject(err);\r\n                    }\r\n                    else\r\n                    {\r\n                        resolve(sound);\r\n                    }\r\n                    asset.data?.loaded?.(err, sound);\r\n                },\r\n            }));\r\n\r\n            getInstance().add(getAlias(asset), sound);\r\n\r\n            return sound;\r\n        },\r\n\r\n        /** Remove the sound from the library */\r\n        async unload(_sound: Sound, asset: ResolvedAsset): Promise<void>\r\n        {\r\n            getInstance().remove(getAlias(asset));\r\n        },\r\n    } as LoaderParser<Sound>,\r\n} as AssetExtension;\r\n\r\nextensions.add(soundAsset);\r\n\r\nexport { soundAsset };\r\n","import * as filters from './filters';\r\nimport * as htmlaudio from './htmlaudio';\r\nimport { setInstance } from './instance';\r\nimport { SoundLibrary } from './SoundLibrary';\r\nimport * as utils from './utils';\r\nimport * as webaudio from './webaudio';\r\n\r\nconst sound = setInstance(new SoundLibrary());\r\n\r\nexport * from './Filterable';\r\nexport * from './filters/Filter';\r\nexport * from './interfaces';\r\nexport * from './Sound';\r\nexport * from './soundAsset';\r\nexport * from './SoundLibrary';\r\nexport * from './SoundSprite';\r\nexport {\r\n    filters,\r\n    htmlaudio,\r\n    sound,\r\n    utils,\r\n    webaudio,\r\n};\r\n","import {\r\n    Filterable,\r\n    filters,\r\n    htmlaudio,\r\n    Sound,\r\n    sound,\r\n    soundAsset,\r\n    SoundLibrary,\r\n    SoundSprite,\r\n    utils,\r\n    webaudio\r\n} from './index';\r\n\r\nObject.defineProperties(sound,\r\n    {\r\n        Filterable: { get() { return Filterable; } },\r\n        filters: { get() { return filters; } },\r\n        htmlaudio: { get() { return htmlaudio; } },\r\n        Sound: { get() { return Sound; } },\r\n        SoundLibrary: { get() { return SoundLibrary; } },\r\n        SoundSprite: { get() { return SoundSprite; } },\r\n        utils: { get() { return utils; } },\r\n        webaudio: { get() { return webaudio; } },\r\n        sound: { get() { return sound; } },\r\n        soundAsset: { get() { return soundAsset; } },\r\n    });\r\n\r\n/**\r\n * For browser bundle, we'll wrap everything in a single default export.\r\n * This will be accessible from `PIXI.sound`. For the ESM/CJS bundles\r\n * we export everything as named.\r\n * @ignore\r\n */\r\nexport default sound;\r\n\r\n"],"names":["instance","setInstance","sound","getInstance","destination","source","_a","Filter","amount","distortion","audioContext","value","scaledValue","samples","curve","deg","i","x","param","context","_EqualizerFilter","f32","f64","f125","f250","f500","f1k","f2k","f4k","f8k","f16k","bands","equalizerBands","band","node","WebAudioUtils","frequency","gain","EqualizerFilter","merger","splitter","seconds","decay","reverse","min","max","rate","length","impulse","impulseL","impulseR","n","convolver","pan","stereo","panner","lpf1","lpf2","hpf1","hpf2","t$1","EventEmitter","_filters","id","_HTMLAudioInstance","parent","name","currentTime","paused","media","speed","volume","loop","muted","global","globalVolume","soundVolume","instanceVolume","pausedReal","options","start","end","Ticker","HTMLAudioInstance","HTMLAudioMedia","callback","onLoad","removeListeners","onAbort","onError","message","complete","extensions","mimes","supported","validateFormats","typeOverrides","overrides","__spreadValues","audio","formats","no","ext","canByExt","canByType","m$2","filters","filter","duration","enabled","force","now","delta","progress","soundLength","err","n$2","input","output","prevFilter","_WebAudioNodes","Filterable","bufferSource","analyser","orig","WebAudioNodes","WebAudioInstance","buffer","url","arrayBuffer","DOMAdapter","audioBufferReadyFn","_Sound","WebAudioMedia","urls","file","path","a","b","data","results","alias","sprite","SoundSprite","resolve","reject","len","index","Sound","win","ctx","WebAudioContext","compressor","state","handleError","result","c","l","f","d","s","o","m$1","HTMLAudioContext","filtersAll","sourceOptions","legacy","autoPause","assert","exists","PLAY_ID","playOnce","h","C","v","e","t","g","render","canvas","textureSource","CanvasSource","step","amp","j","datum","sineTone","hertz","nChannels","sampleRate","amplitude","fArray","time","angle","getAlias","asset","src","soundAsset","ExtensionType","exts","LoaderParserPriority","mime","__spreadProps","_b","_sound","SoundLibrary","htmlaudio","utils","webaudio"],"mappings":"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"}