{"version":3,"file":"Sound.mjs","sources":["../src/Sound.ts"],"sourcesContent":["import { path } from 'pixi.js';\r\nimport { Filter } from './filters/Filter';\r\nimport { HTMLAudioMedia } from './htmlaudio/HTMLAudioMedia';\r\nimport { getInstance } from './instance';\r\nimport { IMedia, IMediaContext, IMediaInstance } from './interfaces';\r\nimport { SoundSprite, SoundSpriteData, SoundSprites } from './SoundSprite';\r\nimport { extensions, supported } from './utils/supported';\r\nimport { WebAudioMedia } from './webaudio/WebAudioMedia';\r\n\r\n/**\r\n * Options to use for creating sounds.\r\n */\r\ninterface Options\r\n{\r\n    /**\r\n     * `true` to immediately start preloading.\r\n     * @default false\r\n     */\r\n    autoPlay?: boolean;\r\n    /**\r\n     * `true` to disallow playing multiple layered instances at once.\r\n     * @default false\r\n     */\r\n    singleInstance?: boolean;\r\n    /**\r\n     * The amount of volume 1 = 100%.\r\n     * @default 1\r\n     */\r\n    volume?: number;\r\n    /**\r\n     * The playback rate where 1 is 100% speed.\r\n     * @default 1\r\n     */\r\n    speed?: number;\r\n    /**\r\n     * Global complete callback when play is finished.\r\n     * @type {Function}\r\n     */\r\n    complete?: CompleteCallback;\r\n    /**\r\n     * Call when finished loading.\r\n     * @type {Function}\r\n     */\r\n    loaded?: LoadedCallback;\r\n    /**\r\n     * `true` to immediately start preloading if loading from `url`.\r\n     */\r\n    preload?: boolean;\r\n    /**\r\n     * Initial loop value, `true` is loop infinitely\r\n     * @default false\r\n     */\r\n    loop?: boolean;\r\n    /**\r\n     * The source of the file being loaded\r\n     */\r\n    url?: string | string[];\r\n    /**\r\n     * If sound is already preloaded, available.\r\n     */\r\n    source?: ArrayBuffer | AudioBuffer | HTMLAudioElement;\r\n    /**\r\n     * The map of sprite data. Where a sprite is an object\r\n     * with a `start` and `end`, which are the times in seconds. Optionally, can include\r\n     * a `speed` amount where 1 is 100% speed.\r\n     */\r\n    sprites?: Record<string, SoundSpriteData>;\r\n}\r\n\r\n/**\r\n * Options used for sound playback.\r\n */\r\ninterface PlayOptions\r\n{\r\n    /**\r\n     * Start time offset in seconds.\r\n     * @default 0\r\n     */\r\n    start?: number;\r\n    /**\r\n     * End time in seconds.\r\n     */\r\n    end?: number;\r\n    /**\r\n     * Override default speed, default to the Sound's speed setting.\r\n     */\r\n    speed?: number;\r\n    /**\r\n    * Override default loop, default to the Sound's loop setting.\r\n    */\r\n    loop?: boolean;\r\n    /**\r\n     * Override default volume, default to the Sound's volume setting.\r\n     */\r\n    volume?: number;\r\n    /**\r\n     * The sprite to play.\r\n     */\r\n    sprite?: string;\r\n    /**\r\n     * If sound instance is muted by default.\r\n     * @default false\r\n     */\r\n    muted?: boolean;\r\n    /**\r\n     * Filters that apply to play.\r\n     * Only supported with WebAudio.\r\n     */\r\n    filters?: Filter[];\r\n    /**\r\n     * When completed.\r\n     * @type {Function}\r\n     */\r\n    complete?: CompleteCallback;\r\n    /**\r\n     * If not already preloaded, callback when finishes load.\r\n     * @type {Function}\r\n     */\r\n    loaded?: LoadedCallback;\r\n    /**\r\n     * Setting `true` will stop any playing instances. This is the same as\r\n     * the singleInstance property on Sound, but is play-specific.\r\n     */\r\n    singleInstance?: boolean;\r\n}\r\n\r\n/**\r\n * Callback when sound is loaded.\r\n * @ignore\r\n * @param {Error} err - The callback error.\r\n * @param {Sound} sound - The instance of new sound.\r\n * @param {IMediaInstance} instance - The instance of auto-played sound.\r\n */\r\ntype LoadedCallback = (err: Error, sound?: Sound, instance?: IMediaInstance) => void;\r\n\r\n/**\r\n * Callback when sound is completed.\r\n * @ignore\r\n * @param {Sound} sound - The instance of sound.\r\n */\r\ntype CompleteCallback = (sound: Sound) => void;\r\n\r\ntype SoundSpriteDataMap = Record<string, SoundSpriteData>;\r\n\r\n/**\r\n * Sound represents a single piece of loaded media. When playing a sound {@link IMediaInstance} objects\r\n * are created. Properties such a `volume`, `pause`, `mute`, `speed`, etc will have an effect on all instances.\r\n */\r\nclass Sound\r\n{\r\n    /** Pool of instances */\r\n    private static _pool: IMediaInstance[] = [];\r\n\r\n    /**\r\n     * `true` if the buffer is loaded.\r\n     * @default false\r\n     */\r\n    public isLoaded: boolean;\r\n\r\n    /**\r\n     * `true` if the sound is currently being played.\r\n     * @default false\r\n     * @readonly\r\n     */\r\n    public isPlaying: boolean;\r\n\r\n    /**\r\n     * true to start playing immediate after load.\r\n     * @default false\r\n     * @readonly\r\n     */\r\n    public autoPlay: boolean;\r\n\r\n    /**\r\n     * `true` to disallow playing multiple layered instances at once.\r\n     * @default false\r\n     */\r\n    public singleInstance: boolean;\r\n\r\n    /**\r\n     * `true` to immediately start preloading.\r\n     * @default false\r\n     * @readonly\r\n     */\r\n    public preload: boolean;\r\n\r\n    /**\r\n     * The file source to load.\r\n     * @readonly\r\n     */\r\n    public url: string;\r\n\r\n    /**\r\n     * The constructor options.\r\n     * @readonly\r\n     */\r\n    public options: Options;\r\n\r\n    /** The audio source */\r\n    public media: IMedia;\r\n\r\n    /** The list of play calls while waiting to preload the sound. */\r\n    private _preloadQueue: (() => void)[] | null;\r\n\r\n    /** The collection of instances being played. */\r\n    private _instances: IMediaInstance[];\r\n\r\n    /** The user defined sound sprites. */\r\n    private _sprites: SoundSprites;\r\n\r\n    /** The options when auto-playing. */\r\n    private _autoPlayOptions: PlayOptions;\r\n\r\n    /** The internal volume. */\r\n    private _volume: number;\r\n\r\n    /** The internal paused state. */\r\n    private _paused: boolean;\r\n\r\n    /** The internal muted state. */\r\n    private _muted: boolean;\r\n\r\n    /** The internal volume. */\r\n    private _loop: boolean;\r\n\r\n    /** The internal playbackRate */\r\n    private _speed: number;\r\n\r\n    /**\r\n     * Create a new sound instance from source.\r\n     * @param source - Either the path or url to the source file.\r\n     *        or the object of options to use.\r\n     * @return Created sound instance.\r\n     */\r\n    public static from(source: string | string[] | Options | ArrayBuffer | HTMLAudioElement | AudioBuffer): Sound\r\n    {\r\n        let options: Options = {};\r\n\r\n        if (typeof source === 'string')\r\n        {\r\n            options.url = source as string;\r\n        }\r\n        else if (source instanceof ArrayBuffer || source instanceof AudioBuffer || source instanceof HTMLAudioElement)\r\n        {\r\n            options.source = source;\r\n        }\r\n        else if (Array.isArray(source))\r\n        {\r\n            options.url = source;\r\n        }\r\n        else\r\n        {\r\n            options = source;\r\n        }\r\n\r\n        // Default settings\r\n        options = {\r\n            autoPlay: false,\r\n            singleInstance: false,\r\n            url: null,\r\n            source: null,\r\n            preload: false,\r\n            volume: 1,\r\n            speed: 1,\r\n            complete: null,\r\n            loaded: null,\r\n            loop: false, ...options\r\n        };\r\n\r\n        Object.freeze(options);\r\n\r\n        const media: IMedia = getInstance().useLegacy\r\n            ? new HTMLAudioMedia()\r\n            : new WebAudioMedia();\r\n\r\n        return new Sound(media, options);\r\n    }\r\n\r\n    /**\r\n     * Use `Sound.from`\r\n     * @ignore\r\n     */\r\n    constructor(media: IMedia, options: Options)\r\n    {\r\n        this.media = media;\r\n        this.options = options;\r\n        this._instances = [];\r\n        this._sprites = {};\r\n\r\n        this.media.init(this);\r\n\r\n        const complete = options.complete;\r\n\r\n        this._autoPlayOptions = complete ? { complete } : null;\r\n        this.isLoaded = false;\r\n        this._preloadQueue = null;\r\n        this.isPlaying = false;\r\n        this.autoPlay = options.autoPlay;\r\n        this.singleInstance = options.singleInstance;\r\n        this.preload = options.preload || this.autoPlay;\r\n\r\n        this.url = Array.isArray(options.url)\r\n            ? this.preferUrl(options.url)\r\n            : options.url;\r\n        this.speed = options.speed;\r\n        this.volume = options.volume;\r\n        this.loop = options.loop;\r\n\r\n        if (options.sprites)\r\n        {\r\n            this.addSprites(options.sprites);\r\n        }\r\n\r\n        if (this.preload)\r\n        {\r\n            this._preload(options.loaded);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Internal help for resolving which file to use if there are multiple provide\r\n     * this is especially helpful for working with bundlers (non Assets loading).\r\n     */\r\n    private preferUrl(urls: string[]): string\r\n    {\r\n        const [file] = urls\r\n            .map((url) => ({ url, ext: path.extname(url).slice(1) }))\r\n            .filter(({ ext }) => supported[ext])\r\n            .sort((a, b) => extensions.indexOf(a.ext) - extensions.indexOf(b.ext));\r\n\r\n        if (!file)\r\n        {\r\n            throw new Error('No supported file type found');\r\n        }\r\n\r\n        return file.url;\r\n    }\r\n\r\n    /** Instance of the media context. */\r\n    public get context(): IMediaContext\r\n    {\r\n        return getInstance().context;\r\n    }\r\n\r\n    /** Stops all the instances of this sound from playing. */\r\n    public pause(): this\r\n    {\r\n        this.isPlaying = false;\r\n        this.paused = true;\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Resuming all the instances of this sound from playing */\r\n    public resume(): this\r\n    {\r\n        this.isPlaying = this._instances.length > 0;\r\n        this.paused = false;\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Stops all the instances of this sound from playing. */\r\n    public get paused(): boolean\r\n    {\r\n        return this._paused;\r\n    }\r\n    public set paused(paused: boolean)\r\n    {\r\n        this._paused = paused;\r\n        this.refreshPaused();\r\n    }\r\n\r\n    /** The playback rate. */\r\n    public get speed(): number\r\n    {\r\n        return this._speed;\r\n    }\r\n    public set speed(speed: number)\r\n    {\r\n        this._speed = speed;\r\n        this.refresh();\r\n    }\r\n\r\n    /** Set the filters. Only supported with WebAudio. */\r\n    public get filters(): Filter[]\r\n    {\r\n        return this.media.filters;\r\n    }\r\n    public set filters(filters: Filter[])\r\n    {\r\n        this.media.filters = filters;\r\n    }\r\n\r\n    /**\r\n     * Add a sound sprite, which is a saved instance of a longer sound.\r\n     * Similar to an image spritesheet.\r\n     * @param alias - The unique name of the sound sprite.\r\n     * @param data - Either completed function or play options.\r\n     */\r\n    public addSprites(alias: string, data: SoundSpriteData): SoundSprite;\r\n\r\n    /**\r\n     * Convenience method to add more than one sprite add a time.\r\n     * @param data - Map of sounds to add where the key is the alias,\r\n     *        and the data are configuration options.\r\n     * @return The map of sound sprites added.\r\n     */\r\n    public addSprites(data: SoundSpriteDataMap): SoundSprites;\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    public addSprites(source: string | SoundSpriteDataMap, data?: SoundSpriteData): any\r\n    {\r\n        if (typeof source === 'object')\r\n        {\r\n            const results: SoundSprites = {};\r\n\r\n            for (const alias in source)\r\n            {\r\n                results[alias] = this.addSprites(alias, source[alias]);\r\n            }\r\n\r\n            return results;\r\n        }\r\n\r\n        // eslint-disable-next-line no-console\r\n        console.assert(!this._sprites[source], `Alias ${source} is already taken`);\r\n        const sprite = new SoundSprite(this, data);\r\n\r\n        this._sprites[source] = sprite;\r\n\r\n        return sprite;\r\n    }\r\n\r\n    /** Destructor, safer to use `SoundLibrary.remove(alias)` to remove this sound. */\r\n    public destroy(): void\r\n    {\r\n        this._removeInstances();\r\n        this.removeSprites();\r\n        this.media.destroy();\r\n        this.media = null;\r\n        this._sprites = null;\r\n        this._instances = null;\r\n    }\r\n\r\n    /**\r\n     * Remove a sound sprite.\r\n     * @param alias - The unique name of the sound sprite, if alias is omitted, removes all sprites.\r\n     */\r\n    public removeSprites(alias?: string): Sound\r\n    {\r\n        if (!alias)\r\n        {\r\n            for (const name in this._sprites)\r\n            {\r\n                this.removeSprites(name);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            const sprite: SoundSprite = this._sprites[alias];\r\n\r\n            if (sprite !== undefined)\r\n            {\r\n                sprite.destroy();\r\n                delete this._sprites[alias];\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /** If the current sound is playable (loaded). */\r\n    public get isPlayable(): boolean\r\n    {\r\n        return this.isLoaded && this.media && this.media.isPlayable;\r\n    }\r\n\r\n    /** Stops all the instances of this sound from playing. */\r\n    public stop(): this\r\n    {\r\n        if (!this.isPlayable)\r\n        {\r\n            this.autoPlay = false;\r\n            this._autoPlayOptions = null;\r\n\r\n            return this;\r\n        }\r\n        this.isPlaying = false;\r\n\r\n        // Go in reverse order so we don't skip items\r\n        for (let i = this._instances.length - 1; i >= 0; i--)\r\n        {\r\n            this._instances[i].stop();\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Play a sound sprite, which is a saved instance of a longer sound.\r\n     * Similar to an image spritesheet.\r\n     * @method play\r\n     * @instance\r\n     * @param alias - The unique name of the sound sprite.\r\n     * @param {Function} callback - Callback when completed.\r\n     * @return The sound instance,\r\n     *        this cannot be reused after it is done playing. Returns a Promise if the sound\r\n     *        has not yet loaded.\r\n     */\r\n    public play(alias: string, callback?: CompleteCallback): IMediaInstance | Promise<IMediaInstance>;\r\n\r\n    /**\r\n     * Plays the sound.\r\n     * @method play\r\n     * @instance\r\n     * @param {Function|PlayOptions} source - Either completed function or play options.\r\n     * @param {Function} callback - Callback when completed.\r\n     * @return The sound instance,\r\n     *        this cannot be reused after it is done playing. Returns a Promise if the sound\r\n     *        has not yet loaded.\r\n     */\r\n    public play(source?: string | PlayOptions | CompleteCallback,\r\n        callback?: CompleteCallback): IMediaInstance | Promise<IMediaInstance>;\r\n\r\n    // Overloaded function\r\n    public play(source?: string | PlayOptions | CompleteCallback,\r\n        complete?: CompleteCallback): IMediaInstance | Promise<IMediaInstance>\r\n    {\r\n        let options: PlayOptions;\r\n\r\n        if (typeof source === 'string')\r\n        {\r\n            const sprite: string = source as string;\r\n\r\n            options = { sprite, loop: this.loop, complete };\r\n        }\r\n        else if (typeof source === 'function')\r\n        {\r\n            options = {};\r\n            options.complete = source as CompleteCallback;\r\n        }\r\n        else\r\n        {\r\n            options = source as PlayOptions;\r\n        }\r\n\r\n        options = {\r\n            complete: null,\r\n            loaded: null,\r\n            sprite: null,\r\n            end: null,\r\n            start: 0,\r\n            volume: 1,\r\n            speed: 1,\r\n            muted: false,\r\n            loop: false, ...(options || {})\r\n        };\r\n\r\n        // A sprite is specified, add the options\r\n        if (options.sprite)\r\n        {\r\n            const alias: string = options.sprite;\r\n\r\n            // eslint-disable-next-line no-console\r\n            console.assert(!!this._sprites[alias], `Alias ${alias} is not available`);\r\n            const sprite: SoundSprite = this._sprites[alias];\r\n\r\n            options.start = sprite.start + (options.start || 0);\r\n            options.end = sprite.end;\r\n            options.speed = sprite.speed || 1;\r\n            options.loop = sprite.loop || options.loop;\r\n            delete options.sprite;\r\n        }\r\n\r\n        // @deprecated offset option\r\n        if ((options as any).offset)\r\n        {\r\n            options.start = (options as any).offset as number;\r\n        }\r\n\r\n        // if not yet playable, ignore\r\n        // - usefull when the sound download isnt yet completed\r\n        if (!this.isLoaded)\r\n        {\r\n            // Handle the case when trying to play a sound that is not yet loaded\r\n            // We'll add it to a queue to play after initial load finishes\r\n            if (this._preloadQueue)\r\n            {\r\n                return new Promise<IMediaInstance>((resolve) =>\r\n                {\r\n                    this._preloadQueue.push(() =>\r\n                    {\r\n                        resolve(this.play(options));\r\n                    });\r\n                });\r\n            }\r\n\r\n            this._preloadQueue = [];\r\n            this.autoPlay = true;\r\n            this._autoPlayOptions = options;\r\n\r\n            return new Promise<IMediaInstance>((resolve, reject) =>\r\n            {\r\n                this._preload((err: Error, sound: Sound, media: IMediaInstance) =>\r\n                {\r\n                    this._preloadQueue.forEach((resolve) => resolve());\r\n                    this._preloadQueue = null;\r\n\r\n                    if (err)\r\n                    {\r\n                        reject(err);\r\n                    }\r\n                    else\r\n                    {\r\n                        if (options.loaded)\r\n                        {\r\n                            options.loaded(err, sound, media);\r\n                        }\r\n                        resolve(media);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n\r\n        // Stop all sounds\r\n        if (this.singleInstance || options.singleInstance)\r\n        {\r\n            this._removeInstances();\r\n        }\r\n\r\n        // clone the bufferSource\r\n        const instance = this._createInstance();\r\n\r\n        this._instances.push(instance);\r\n        this.isPlaying = true;\r\n        instance.once('end', () =>\r\n        {\r\n            if (options.complete)\r\n            {\r\n                options.complete(this);\r\n            }\r\n            this._onComplete(instance);\r\n        });\r\n        instance.once('stop', () =>\r\n        {\r\n            this._onComplete(instance);\r\n        });\r\n\r\n        instance.play(options);\r\n\r\n        return instance;\r\n    }\r\n\r\n    /** Internal only, speed, loop, volume change occured. */\r\n    public refresh(): void\r\n    {\r\n        const len = this._instances.length;\r\n\r\n        for (let i = 0; i < len; i++)\r\n        {\r\n            this._instances[i].refresh();\r\n        }\r\n    }\r\n\r\n    /** Handle changes in paused state. Internal only. */\r\n    public refreshPaused(): void\r\n    {\r\n        const len = this._instances.length;\r\n\r\n        for (let i = 0; i < len; i++)\r\n        {\r\n            this._instances[i].refreshPaused();\r\n        }\r\n    }\r\n\r\n    /** Gets and sets the volume. */\r\n    public get volume(): number\r\n    {\r\n        return this._volume;\r\n    }\r\n    public set volume(volume: number)\r\n    {\r\n        this._volume = volume;\r\n        this.refresh();\r\n    }\r\n\r\n    /** Gets and sets the muted flag. */\r\n    public get muted(): boolean\r\n    {\r\n        return this._muted;\r\n    }\r\n    public set muted(muted: boolean)\r\n    {\r\n        this._muted = muted;\r\n        this.refresh();\r\n    }\r\n\r\n    /** Gets and sets the looping. */\r\n    public get loop(): boolean\r\n    {\r\n        return this._loop;\r\n    }\r\n    public set loop(loop: boolean)\r\n    {\r\n        this._loop = loop;\r\n        this.refresh();\r\n    }\r\n\r\n    /** Starts the preloading of sound. */\r\n    private _preload(callback?: LoadedCallback): void\r\n    {\r\n        this.media.load(callback);\r\n    }\r\n\r\n    /** Gets the list of instances that are currently being played of this sound. */\r\n    public get instances(): IMediaInstance[]\r\n    {\r\n        return this._instances;\r\n    }\r\n\r\n    /** Get the map of sprites. */\r\n    public get sprites(): SoundSprites\r\n    {\r\n        return this._sprites;\r\n    }\r\n\r\n    /** Get the duration of the audio in seconds. */\r\n    public get duration(): number\r\n    {\r\n        return this.media.duration;\r\n    }\r\n\r\n    /** Auto play the first instance. */\r\n    public autoPlayStart(): IMediaInstance\r\n    {\r\n        let instance: IMediaInstance;\r\n\r\n        if (this.autoPlay)\r\n        {\r\n            instance = this.play(this._autoPlayOptions) as IMediaInstance;\r\n        }\r\n\r\n        return instance;\r\n    }\r\n\r\n    /** Removes all instances. */\r\n    private _removeInstances(): void\r\n    {\r\n        // destroying also stops\r\n        for (let i = this._instances.length - 1; i >= 0; i--)\r\n        {\r\n            this._poolInstance(this._instances[i]);\r\n        }\r\n        this._instances.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Sound instance completed.\r\n     * @param instance\r\n     */\r\n    private _onComplete(instance: IMediaInstance): void\r\n    {\r\n        if (this._instances)\r\n        {\r\n            const index = this._instances.indexOf(instance);\r\n\r\n            if (index > -1)\r\n            {\r\n                this._instances.splice(index, 1);\r\n            }\r\n            this.isPlaying = this._instances.length > 0;\r\n        }\r\n        this._poolInstance(instance);\r\n    }\r\n\r\n    /** Create a new instance. */\r\n    private _createInstance(): IMediaInstance\r\n    {\r\n        if (Sound._pool.length > 0)\r\n        {\r\n            const instance: IMediaInstance = Sound._pool.pop();\r\n\r\n            instance.init(this.media);\r\n\r\n            return instance;\r\n        }\r\n\r\n        return this.media.create();\r\n    }\r\n\r\n    /**\r\n     * Destroy/recycling the instance object.\r\n     * @param instance - Instance to recycle\r\n     */\r\n    private _poolInstance(instance: IMediaInstance): void\r\n    {\r\n        instance.destroy();\r\n        // Add it if it isn't already added\r\n        if (Sound._pool.indexOf(instance) < 0)\r\n        {\r\n            Sound._pool.push(instance);\r\n        }\r\n    }\r\n}\r\n\r\nexport { Sound };\r\nexport type {\r\n    CompleteCallback,\r\n    LoadedCallback,\r\n    Options,\r\n    PlayOptions,\r\n    SoundSpriteDataMap\r\n};\r\n"],"names":["resolve"],"mappings":"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"}